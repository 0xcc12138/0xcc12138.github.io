<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>PE | Cc12138's blog</title><meta name="author" content="Ccai"><meta name="copyright" content="Ccai"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="用010Editor解析PE头首先打开模板  然后按 Alt + 4 即可  效果如图 PE头 以上是参考图 1.DOS部分1234567typedef struct _IMAE_DOS_HEADER&#x2F;&#x2F;  偏移, 意义&#123;     WORD e_magic;              &#x2F;&#x2F;  0x00, &#x27;MZ&#x27;（0x5A4D）标识         ......中间成">
<meta property="og:type" content="article">
<meta property="og:title" content="PE">
<meta property="og:url" content="http://example.com/PE/index.html">
<meta property="og:site_name" content="Cc12138&#39;s blog">
<meta property="og:description" content="用010Editor解析PE头首先打开模板  然后按 Alt + 4 即可  效果如图 PE头 以上是参考图 1.DOS部分1234567typedef struct _IMAE_DOS_HEADER&#x2F;&#x2F;  偏移, 意义&#123;     WORD e_magic;              &#x2F;&#x2F;  0x00, &#x27;MZ&#x27;（0x5A4D）标识         ......中间成">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/WangFei2.jpg">
<meta property="article:published_time" content="2024-09-27T12:28:00.000Z">
<meta property="article:modified_time" content="2024-09-27T12:28:00.000Z">
<meta property="article:author" content="Ccai">
<meta property="article:tag" content="PE">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/WangFei2.jpg"><link rel="shortcut icon" href="/img/rose.png"><link rel="canonical" href="http://example.com/PE/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'PE',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-27 20:28:00'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/WangFei2.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">72</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">30</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Cc12138's blog"><span class="site-name">Cc12138's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">PE</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-09-27T12:28:00.000Z" title="发表于 2024-09-27 20:28:00">2024-09-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-27T12:28:00.000Z" title="更新于 2024-09-27 20:28:00">2024-09-27</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="PE"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="用010Editor解析PE头"><a href="#用010Editor解析PE头" class="headerlink" title="用010Editor解析PE头"></a>用010Editor解析PE头</h1><p>首先打开模板</p>
<p><img src="/PE/1712839823644.png" alt="1712839823644"></p>
<p>然后按 Alt + 4 即可</p>
<p><img src="/PE/1712839924887.png" alt="1712839924887"></p>
<p>效果如图</p>
<h1 id="PE头"><a href="#PE头" class="headerlink" title="PE头"></a>PE头</h1><p><img src="/PE/1712832201352.png" alt="1712832201352"></p>
<p>以上是参考图</p>
<h2 id="1-DOS部分"><a href="#1-DOS部分" class="headerlink" title="1.DOS部分"></a>1.DOS部分</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAE_DOS_HEADER</span><span class="comment">//  偏移, 意义</span></span><br><span class="line">&#123; </span><br><span class="line">    WORD e_magic;              <span class="comment">//  0x00, &#x27;MZ&#x27;（0x5A4D）标识 </span></span><br><span class="line">        ......中间成员为兼容<span class="number">16</span>位操作系统,可修改可忽略......</span><br><span class="line">    LONG e_lfanew;             <span class="comment">//  0x3C, PE头的起始地址，默认0xB0处</span></span><br><span class="line">&#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>1.WORD e_magic（0x00处）<br>● 对应PE文件的开头，是PE文件DOS头的标识符”MZ”→0x5A4D<br>  ○ 对应Winnt.h头文件中宏定义: #define IMAGE_DOS_SIGNATURE 0x4D5A &#x2F;&#x2F; MZ<br>2.LONG e_lfanew（0x3C处）<br>● 对应PE文件0x3C处指向NT头在文件中的偏移（默认0xB0），即32位及以上系统文件头在文件中真正的偏移</p>
<h2 id="2-NT头"><a href="#2-NT头" class="headerlink" title="2.NT头"></a>2.NT头</h2><p><img src="/PE/1712832042886.png" alt="1712832042886"> </p>
<p><strong>“NT” 在这里是 “New Technology” 的缩写，完整的单词是 “New Technology”。</strong>  它们的内核相比之前的 MS-DOS 和 Windows 95&#x2F;98 等系统有了重大的改进和升级。 </p>
<h3 id="文件头结构体"><a href="#文件头结构体" class="headerlink" title="文件头结构体"></a><strong>文件头结构体</strong></h3><p><strong>IMAGE_FILE_HEADER FileHeader</strong></p>
<ul>
<li>MAGE_FILE_HEADER：描述磁盘上PE文件的相关信息。</li>
<li>定位文件头地址：DOS头中的e_lfanew+4（位于NT头标识的地址+0x4）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件头结构体： _IMAGE_FILE_HEADER</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_FILE_HEADER</span>&#123;</span><br><span class="line">     WORD Machine;                               <span class="comment">// +0x00, 指定程序的运行平台，勿改</span></span><br><span class="line">     WORD NumberOfSections;          <span class="comment">// +0x02, PE中的节/块(section)数量，勿改</span></span><br><span class="line">     DWORD TimeDateStamp;                <span class="comment">// +0x04, 时间戳：链接器填写的文件生成时间</span></span><br><span class="line">     DWORD PointerToSymbolTable;  <span class="comment">// +0x08, 指向符号表的地址(主要用于调试)</span></span><br><span class="line">     DWORD NumberOfSymbols;          <span class="comment">// +0x0C, 符号表中符号个数(同上)</span></span><br><span class="line">     WORD SizeOfOptionalHeader;  <span class="comment">// +0x10, IMAGE_OPTIONAL_HEADER32选项头结构大小，勿改</span></span><br><span class="line">     WORD Characteristics;               <span class="comment">// +0x12, 文件属性，勿改</span></span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//* 字段1：Machine 表CPU的类型, 定义在windows.h中，常用类型</span></span><br><span class="line">            <span class="number">32</span>位：<span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_I386, 0x014c　<span class="comment">// Intel 386, x86</span></span></span><br><span class="line">            <span class="number">64</span>位：<span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_AMD64, 0x8664 <span class="comment">// AMD64(KB), x64</span></span></span><br><span class="line"><span class="comment">//* 字段2：NumberOfSections 表PE中的节(section)数量：</span></span><br><span class="line">            节表紧跟在IMAGE_NT_HEADERS后面,此字段决定了节表中元素的个数，即节的个数</span><br><span class="line">      遍历节表经验：根据此处的个数拿对应的节表数据</span><br><span class="line"><span class="comment">//* 字段6：SizeOfOptionalHeader 表IMAGE_OPTIONAL_HEADER32 结构大小</span></span><br><span class="line">            定位节表位置=选项头地址+选项头大小</span><br><span class="line"><span class="comment">//* 字段7： Characteristics 表文件属性,EXE默认0100,DLL默认210Eh,或运算组合设置。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_RELOCS_STRIPPED　　　　 0x0001　<span class="comment">// 文件中不存在重定位信息</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_EXECUTABLE_IMAGE　　　　0x0002　<span class="comment">// 文件可执行</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_LINE_NUMS_STRIPPED　　　0x0004　<span class="comment">// 文件中不存在行信息</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_LOCAL_SYMS_STRIPPED　　 0x0008　<span class="comment">// 文件中不存在符号信息</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_AGGRESIVE_WS_TRIM　　　 0x0010　<span class="comment">// 调整工作集</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_LARGE_ADDRESS_AWARE　　 0x0020　<span class="comment">// 程序能处理大于2G的地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_BYTES_REVERSED_LO　　　 0x0080　<span class="comment">// 小尾方式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_32BIT_MACHINE　　　　　 0x0100　<span class="comment">// 只在32位平台上运行</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_DEBUG_STRIPPED　　　　　0x0200　<span class="comment">// 不包含调试信息</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP　0x0400　<span class="comment">// 不能从可移动盘运行</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_NET_RUN_FROM_SWAP　　　　0x0800　<span class="comment">// 不能从网络运行 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_SYSTEM　　　　　　　　　　0x1000　<span class="comment">// 系统文件（如驱动程序），不能直接运行</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_DLL　　　　　　　　　　　 0x2000　<span class="comment">// 是一个dll文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_UP_SYSTEM_ONLY　　　　　 0x4000　<span class="comment">// 文件不能在多处理器计算机上运行</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_BYTES_REVERSED_HI　　　  0x8000　<span class="comment">// 大尾方式</span></span></span><br></pre></td></tr></table></figure>





<h3 id="选项头结构体"><a href="#选项头结构体" class="headerlink" title="选项头结构体"></a>选项头结构体</h3><p><strong>IMAGE_OPTIONAL_HEADER（区分32位和64位）</strong></p>
<ul>
<li>IMAGE_FILE_HEADER：：以供操作系统加载PE文件使用，必选。</li>
<li>定位选项头地址：DOS头中的e_lfanew+4+0x14（文件头大小）。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 32位选项头结构体：_IMAGE_OPTIONAL_HEADER</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_OPTIONAL_HEADER</span></span><br><span class="line">&#123;</span><br><span class="line">    WORD   Magic;                            <span class="comment">//* PE标志字：32位（0x10B），64位（0x20B）</span></span><br><span class="line">    BYTE   MajorLinkerVersion;               <span class="comment">//  主链接器版本号</span></span><br><span class="line">    BYTE   MinorLinkerVersion;               <span class="comment">//  副链接器版本号</span></span><br><span class="line">    DWORD  SizeOfCode;                        <span class="comment">//  代码所占空间大小（代码节大小）</span></span><br><span class="line">    DWORD  SizeOfInitializedData;         <span class="comment">//  已初始化数据所占空间大小</span></span><br><span class="line">    DWORD  SizeOfUninitializedData;           <span class="comment">//  未初始化数据所占空间大小</span></span><br><span class="line">    DWORD  AddressOfEntryPoint;               <span class="comment">//* 程序执行入口RVA，(w)(Win)mainCRTStartup：即0D首次断下来的自进程地址,也就是我们常说的OEP</span></span><br><span class="line">    DWORD  BaseOfCode;                        <span class="comment">//  代码段基址</span></span><br><span class="line">    DWORD  BaseOfData;                        <span class="comment">//  数据段基址</span></span><br><span class="line">    <span class="comment">//BaseOfCode和BaseOfData是操作系统不依赖的</span></span><br><span class="line">    DWORD  ImageBase;                     <span class="comment">//* （建议）内存加载基址，（模块基址,PE映射到内存的基地址）exe默认0x400000，dll默认0x10000000,主模块一般能被满足，但是Dll一般不能满足</span></span><br><span class="line">    DWORD  SectionAlignment;              <span class="comment">//* 节区数据在内存中的对齐值，一定是4的倍数，一般是0x1000(4096=4K)</span></span><br><span class="line">    DWORD  FileAlignment;                 <span class="comment">//* 节区数据在文件中的对齐值，一般是0x200(磁盘扇区大小512)</span></span><br><span class="line">    WORD   MajorOperatingSystemVersion;      <span class="comment">//  要求操作系统最低版本号的主版本号</span></span><br><span class="line">    WORD   MinorOperatingSystemVersion;      <span class="comment">//  要求操作系统最低版本号的副版本号</span></span><br><span class="line">    WORD   MajorImageVersion;                <span class="comment">//  可运行于操作系统的主版本号</span></span><br><span class="line">    WORD   MinorImageVersion;                <span class="comment">//  可运行于操作系统的次版本号</span></span><br><span class="line">    WORD   MajorSubsystemVersion;            <span class="comment">//  主子系统版本号：不可修改</span></span><br><span class="line">    WORD   MinorSubsystemVersion;            <span class="comment">//  副子系统版本号</span></span><br><span class="line">    DWORD  Win32VersionValue;             <span class="comment">//  版本号：不被病毒利用的话一般为0,XP中不可修改</span></span><br><span class="line">    DWORD  SizeOfImage;                       <span class="comment">//* PE文件在进程内存中的总大小，与SectionAlignment对齐</span></span><br><span class="line">    DWORD  SizeOfHeaders;                 <span class="comment">//* PE文件头部在文件中的按照文件对齐后的总大小（所有头 + 节表）</span></span><br><span class="line">    DWORD  CheckSum;                      <span class="comment">//  对文件做校验，判断文件是否被修改：3环无用，MapFileAndCheckSum获取 驱动会检查这个值</span></span><br><span class="line">    WORD   Subsystem;                        <span class="comment">//  子系统，与连接选项/system相关：1=驱动程序，2=图形界面，3=控制台/Dll</span></span><br><span class="line">    WORD   DllCharacteristics;               <span class="comment">//  文件特性（不是只是Dll）</span></span><br><span class="line">    DWORD  SizeOfStackReserve;                <span class="comment">//  初始化时保留的栈大小</span></span><br><span class="line">    DWORD  SizeOfStackCommit;             <span class="comment">//  初始化时实际提交的栈大小</span></span><br><span class="line">    DWORD  SizeOfHeapReserve;             <span class="comment">//  初始化时保留的堆大小</span></span><br><span class="line">    DWORD  SizeOfHeapCommit;              <span class="comment">//  初始化时实际提交的堆大小</span></span><br><span class="line">    DWORD  LoaderFlags;                       <span class="comment">//  已废弃，与调试有关，默认为 0</span></span><br><span class="line">    DWORD  NumberOfRvaAndSizes;               <span class="comment">//  下边数据目录的项数，此字段自Windows NT发布以来,一直是16</span></span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];<span class="comment">// 数据目录表</span></span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, * PIMAGE_OPTIONAL_HEADER32;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//* 字段6：AddressOfEntryPoint 表 程序入口RVA，即OEP:</span></span><br><span class="line">      EOP:程序入口点，壳相关概念</span><br><span class="line">      OEP:原本的程序入口点（实际为偏移，+模块基址=实际入口点）</span><br><span class="line">      EP: 被加工后的入口点</span><br><span class="line"><span class="comment">//* 字段9：ImageBase 表 模块加载基地址，exe默认0x400000，dll默认0x10000000</span></span><br><span class="line">      建议装载地址：exe映射加载到内存中的首地址= PE <span class="number">0</span>处，即实例句柄hInstance</span><br><span class="line">      一般而言，exe文件可遵从装载地址建议，但dll文件无法满足</span><br><span class="line"><span class="comment">//* 尾字段：DataDirectory 表 数据目录表，用来定义多种不通用处的数据块。</span></span><br><span class="line">      存储了PE中各个表的位置，详情参考IMAGE_DIRECTORY_ENTRY...系列宏</span><br></pre></td></tr></table></figure>



<p> <strong>WORD   DllCharacteristics;一些介绍</strong> </p>
<ol>
<li><strong>IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE（0x0040）</strong>：指示DLL支持ASLR（地址空间布局随机化），使得每次加载时的地址空间布局都不同，增加了系统的安全性。</li>
<li><strong>IMAGE_DLLCHARACTERISTICS_NX_COMPAT（0x0100）</strong>：指示DLL支持DEP（数据执行保护），这样操作系统就可以防止恶意代码在内存中执行。</li>
<li><strong>IMAGE_DLLCHARACTERISTICS_NO_SEH（0x0400）</strong>：指示DLL没有安全异常处理器（SEH），这意味着该DLL可能不支持异常处理。</li>
<li><strong>IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE（0x8000）</strong>：指示DLL是Terminal Server Aware，即它能够识别并适应终端服务器环境。</li>
<li><strong>IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA（0x0020）</strong>：指示DLL需要使用高熵虚拟地址（High Entropy VA），这是一种更高级别的ASLR。</li>
<li><strong>IMAGE_DLLCHARACTERISTICS_APPCONTAINER（0x1000）</strong>：指示DLL运行在AppContainer环境中，这是Windows 8及更新版本引入的一种应用沙箱机制。</li>
</ol>
<p><strong>节表重点成员–数据目录 IMAGE_DATA_DIRECTORY</strong></p>
<ul>
<li>数据目录用来描述PE中各个表的位置及大小信息，重点表：导出表、导入表、重定位表、资源表。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据目录 _IMAGE_DATA_DIRECTORY结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_DATA_DIRECTORY</span> &#123;</span><br><span class="line">  DWORD VirtualAddress;     <span class="comment">/**指向某个数据的相对虚拟地址   RAV  偏移0x00**/</span></span><br><span class="line">  DWORD Size;               <span class="comment">/**某个数据块的大小                 偏移0x04**/</span></span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>参数1VirtualAddress指定了数据块的相对虚拟地址(RVA)，因为当exe在处理导入表的时候，已经映射进进程内存了，取值RVA更方便。</p>
</li>
<li><p>Size则指定了该数据块的大小，有时并不是该类型数据的总大小，可能只是该类型数据一个数据项的大小。这两个成员(主要是VirtualAddress)成为了定位各种表的关键，所以一定要知道每个数组元素所指向的数据块类型，以下表格就是它的对应关系：</p>
</li>
</ul>
<p><img src="/PE/1712833456689.png" alt="1712833456689"></p>
<p> 图:   IMAGE_DATA_DIRECTORY数组元素项图析 </p>
<ul>
<li><p><strong>IMP（导入表）：</strong>导入表用来描述模块调用的API列表，位于PE数据目录中的第二项即DataDirectory[1]，其中记录了导入表的地址和大小，VirtualAddress指向IMAGE_IMPORT_DESCRIPTOR 结构体数组，这个结构体数组中的每个元素对应着一个dll文件，以全0作为最后一个元素结尾。程序产生调用会生成CALL指令，两大问题及解决思路如下：</p>
</li>
<li><ul>
<li><strong>1.地址存放问题：</strong>出于运行环境等因素考虑，导入函数的地址不能为固定地址。所以在exe中保存导入函数的相关信息，系统和链接器对其进行约定：链接器在生成exe的时候，为所有调用API的地方填写一个间接地址，当程序运行起来后，相应地址则会被写入真正API的地址，此区域即为IAT表（导入地址表）；</li>
<li><strong>2.exe如何存储导入dll及其函数信息：</strong>dll与函数是一对多的关系，原则上应该设计为多方填写1方信息的数据关系，但考虑到数据较多的情况，遍历不便。反过来设计为1方存储多方信息的数据结构，虽然会造成插入删除的不方便，但是考虑到exe加载dll的实际场景，无插入删除需求，所以应该设计为后者结构更贴合遍历查询需求。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IMAGE_IMPORT_DESCRIPTOR 导入表结构，以全0（20个0）结尾</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DWORD   Characteristics;     <span class="comment">//  作用1：导入表结束标志</span></span><br><span class="line">        DWORD   OriginalFirstThunk;  <span class="comment">//* 作用2：*RVA指向一个结构体数组(INT表)</span></span><br><span class="line">    &#125;; </span><br><span class="line">    DWORD   TimeDateStamp;           <span class="comment">//  时间戳</span></span><br><span class="line">    DWORD   ForwarderChain;          <span class="comment">//  -1 if no forwarders</span></span><br><span class="line">    DWORD   Name;                    <span class="comment">//* RVA指向以0结尾的dll名字</span></span><br><span class="line">    DWORD   FirstThunk;              <span class="comment">//* RVA指向一个结构体数组(IAT表，DataDirectory[12]项)</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR, *PIMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>IAT（导入地址表）：</strong>IMP中的FirstThunk指向IAT表。</li>
<li><strong>INT（导入名称表）：</strong>IMP中的OriginalFirstThunk指向INT表，也是DataDirectory[12]项。</li>
<li><strong>PE加载前，</strong>IAT和INT都指向_IMAGE_IMPORT_BY_NAME结构体</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/ IMAGE_THUNK_DATA结构体汇总只有一个联合体，</span><br><span class="line"><span class="comment">// 一般用四字节的AddressOfData来获取IMAGE_IMPORT_BY_NAME的地址。</span></span><br><span class="line"><span class="comment">// 四字节解析，看最高位[31]：</span></span><br><span class="line"><span class="comment">//      1表序号导入，低word为导入函数的序号值；</span></span><br><span class="line"><span class="comment">//      0表RVA，指向_IMAGE_IMPORT_BY_NAME；</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_THUNK_DATA32</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        PBYTE  ForwarderString;     <span class="comment">// PBYTE 指向一个转向者字符串的RVA；</span></span><br><span class="line">        PDWORD Function;            <span class="comment">// PDWORD 被输入的函数的内存地址；</span></span><br><span class="line">        DWORD Ordinal;              <span class="comment">// *被输入的API的序数值</span></span><br><span class="line">        PIMAGE_IMPORT_BY_NAME  AddressOfData; <span class="comment">//*RVA 指向IMAGE_IMPORT_BY_NAME</span></span><br><span class="line">    &#125; u1;</span><br><span class="line">&#125; IMAGE_THUNK_DATA32;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// IMAGE_IMPORT_BY_NAME有两个成员：1.序号；2.函数名。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_IMPORT_BY_NAME</span> &#123;</span><br><span class="line">    WORD    Hint;   <span class="comment">// 可能为0，编译器决定，如果不为0，是函数在导出表中的索引</span></span><br><span class="line">    BYTE    Name[<span class="number">1</span>];<span class="comment">// 函数名称以0结尾，由于不知道到底多长，所以干脆只给出第一个字符，找到0结束</span></span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>PE加载后，IAT有变：</strong>加载后的IAT每一项存储的是所对应的导入函数地址。</li>
</ul>
<p><img src="/PE/1712833632524.png" alt="1712833632524"></p>
<h2 id="3-节表"><a href="#3-节表" class="headerlink" title="3.节表"></a>3.节表</h2><p><strong>（1）节表总概</strong> </p>
<ul>
<li>节表：描述PE文件与内存之间的映射关系，由一系列的IMAGE_SECTION_HEADER结构排列而成，每个结构用来描述一个节（每个节占用0x28B），说明PE文件的指定内容拷贝至内存的哪个位置、拷贝大小及内存属性的设置。结构的排列顺序和它们描述的节在文件中的排列顺序是一致的。全部有效结构的最后以一个空的IMAGE_SECTION_HEADER结构作为结束，所以节表中总的IMAGE_SECTION_HEADER结构数量等于节的数量加一。节表总是被存放在紧接在PE文件头的地方。</li>
<li>节表大小 &#x3D; FileHeader.NumberOfSections（节数量）* IMAGE_SECTION_HEADER 结构体。</li>
</ul>
<p><strong>IMAGE_SECTION_HEADER 结构体</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IMAGE_SECTION_HEADER 节表结构体，大小40B</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_SECTION_HEADER</span> &#123;</span><br><span class="line">  BYTE  Name[IMAGE_SIZEOF_SHORT_NAME];  <span class="comment">// 节表名称：描述性字段</span></span><br><span class="line">  <span class="comment">// 下方4个字段：从文件S1处开始，拷贝S2大小的数据，到内存S3处，有效数据占用内存S4大小</span></span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    DWORD PhysicalAddress;</span><br><span class="line">    DWORD VirtualSize;         <span class="comment">// S4:内存大小</span></span><br><span class="line">  &#125; Misc;</span><br><span class="line">  DWORD VirtualAddress;          <span class="comment">// S3:内存地址：基于模块基址</span></span><br><span class="line">  DWORD SizeOfRawData;           <span class="comment">// S2:文件大小</span></span><br><span class="line">  DWORD PointerToRawData;        <span class="comment">// S1:文件偏移</span></span><br><span class="line">  DWORD PointerToRelocations;    <span class="comment">// 无用</span></span><br><span class="line">  DWORD PointerToLinenumbers;    <span class="comment">// 无用</span></span><br><span class="line">  WORD  NumberOfRelocations;    <span class="comment">// 无用</span></span><br><span class="line">  WORD  NumberOfLinenumbers;    <span class="comment">// 无用</span></span><br><span class="line">  DWORD Characteristics;     <span class="comment">// 节属性，取值IMAGE_SCN_...系列宏</span></span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure>



<p>一句话解释就是：</p>
<p>在文件偏移为 DWORD PointerToRawData 处映射 DWORD SizeOfRawData 大小的内容到内存，映射到的内存地址是 DWORD VirtualAddress ，所占的内存大小为 DWORD VirtualSize</p>
<p>下面是Characteristics的属性介绍</p>
<p><img src="/PE/1712833168537.png" alt="1712833168537"></p>
<ul>
<li><p>节表置于选项头之后，节表首地址 计算方法：</p>
</li>
<li><ul>
<li>（1）选项头的地址 + 选项头的大小；</li>
<li>（2） e_lfanew+4+0x14（文件头大小）+0xE0（32位选项头大小）。</li>
</ul>
</li>
</ul>
<h1 id="Dump"><a href="#Dump" class="headerlink" title="Dump:"></a>Dump:</h1><p>我们知道，一个可执行程序从硬盘加载到内存到运行，需要一个拉伸的过程，那么我们可以反过来，能否可以在运行起来的内存里面，还原出一个exe?</p>
<p>这样的一个操作就叫做dump</p>
<p>步骤就是：</p>
<p><strong>PE头拷贝下来，然后节按照节表的定义的区域，拷下来</strong></p>
<p>值得注意的是：</p>
<p>我们最好使用OD，X96dbg先将程序运行到OEP，然后再Dump，这是为什么呢？</p>
<p>原因就是：程序一旦跑起来，程序如果有全局变量，那么就有可能全局变量被赋值，一旦被赋值，如果程序启动时有检测全局变量是否为初始值，不是就退出程序的话，那么Dump下来的程序就是不可用的</p>
<p>以下记录一次Dump之旅，主角：扫雷</p>
<p>首先用x96dbg打开扫雷，运行到oep，然后分析</p>
<p><img src="/PE/1713356633659.png" alt="1713356633659"></p>
<p>选中PE头，然后按下 CTRL C 复制，然后打开一个新的文件，再按下CTRL B粘贴</p>
<p><img src="/PE/1713356746297.png" alt="1713356746297"></p>
<p>然后拷贝节表</p>
<p>接下来是节：</p>
<p><img src="/PE/1713356952203.png" alt="1713356952203"></p>
<p>选中的那一段翻译过来就是，在内存中偏移为0x1000处的地址拷贝0x3A56个字节（这是实际大小，没有对齐），复制到文件偏移为0x400的地址，粘贴0x3c00个字节</p>
<p>但是由于是dump，我们便要按照对齐后的大小，即复制粘贴0x3c00大小的数据</p>
<h1 id="节表注入"><a href="#节表注入" class="headerlink" title="节表注入"></a>节表注入</h1><h2 id="新增节："><a href="#新增节：" class="headerlink" title="新增节："></a>新增节：</h2><p>需要这几个步骤：</p>
<ol>
<li>节表个数加1</li>
<li>节表添加一项</li>
<li>添加节数据</li>
<li>修改SizeOfImage</li>
</ol>
<p><strong>举例子：</strong></p>
<p>目标：把一个exe塞进节表</p>
<p>过程：</p>
<p><strong>首先修改节表个数</strong></p>
<p><img src="/PE/1713405246615.png" alt="1713405246615"></p>
<p>这里改为4（原来是3）</p>
<p><strong>然后添加节表</strong></p>
<p><img src="/PE/1713405270367.png" alt="1713405270367"></p>
<ol>
<li>这里要注意的是，新加的PointrtToRawData也就是文件偏移就等于上一个节表的PointrtToRawData+SizeOfRawData</li>
<li>SizeOfRawData要与FileAlignment对齐，例如我这个的例子是0x200</li>
<li>新加的VirtualAddress是等于上一个节表的VirtualAddress加上VirtualSize与SectionAlignment对齐后的值</li>
</ol>
<p>之前我这里犯了一个错误，添加完数据后，我想反正0x1000也是0x200的倍数，不如直接让SizeOfRawData和0x1000对齐得了，结果反而出错了，推测是从文件映射到内存根本没那么多数据，系统找不到，因此就无法启动</p>
<p><strong>再继续添加节数据：</strong></p>
<p>直接复制粘贴exe的数据进去即可：<br><img src="/PE/1713405575265.png" alt="1713405575265"></p>
<p><strong>修改SizeOfImage</strong></p>
<p>新的SizeOfImage &#x3D; VirtualAddress + VirtualSize与SectionAlignment对齐后的值</p>
<p>但是值得一提的是，新增节可能不会奏效，因为可能在节表那一段没有足够多的空间给我塞下一个新的节表，有可能存储着其他重要数据，而他们是不能够覆盖的</p>
<p>用PETools可以添加节：</p>
<p><img src="/PE/1713441180278.png" alt="1713441180278"></p>
<h2 id="扩展最后一个节："><a href="#扩展最后一个节：" class="headerlink" title="扩展最后一个节："></a>扩展最后一个节：</h2><ol>
<li>修改节表</li>
<li>添加节数据</li>
<li>修改SizeOfImage</li>
</ol>
<p><strong>1.修改节表</strong></p>
<p><img src="/PE/1713431156375.png" alt="1713431156375"></p>
<p>例如我想在原来节的基础上再添加0x3000的数据，首先将两个参数修改一下</p>
<p>就直接先在文件的末尾添加0x3000个字节的0x00，然后再从这个表里复制全部内容到原来的文件末尾处即可</p>
<p><img src="/PE/1713431335313.png" alt="1713431335313"></p>
<p>完成添加</p>
<p><img src="/PE/1713431410600.png" alt="1713431410600"></p>
<p><img src="/PE/1713431400347.png" alt="1713431400347"></p>
<h1 id="导入表："><a href="#导入表：" class="headerlink" title="导入表："></a>导入表：</h1><p>导出表是给别人用的函数的清单，相当于饭店提供的菜单</p>
<p>导入表相当于客人点菜选择的菜品单。上面记录了exe要使用的dll和dll中的函数</p>
<p>数据目录第一项伟导出表，第二项表为导入表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DWORD   Characteristics;            </span><br><span class="line">        DWORD   OriginalFirstThunk;         </span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    DWORD   ForwarderChain;                 </span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   FirstThunk;                     </span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>

<p>定位导入表：	</p>
<p>和之前的好多表一样，VirtualAddress 指向多个一样的导入表结构。</p>
<p>最后 sizeOf ( IMAGE_IMPORT_DESCRIPTOR) 个 0  代表导入表结束</p>
<p>导入表的union只用第二个 OriginalFirstThunk，时间戳 TimeDateStamp 记录了当前程序编译生成的时间</p>
<p>Name 是指向 dll 名的 RVA，只记录了一个 dll 名，所以导入表会有若干张，顺序无缝存放，一张导入表就是一个要使用的 dll，以全0作为结尾</p>
<p>OriginalFirstThunk（导入表结构第一个成员）指向一张叫 INT 的表（import name table，导入名称表），存的是若干个 IMAGE_THUNK_DATA 结构，最后以0结尾作结束标志。</p>
<p>FirstThunk（导入表结构最后一个成员）也指向一张表，IAT表（import address table，导入地址表），找到这张表有两种方式，一种就是通过导入表这里找到，第二种就是通过数据目录表，倒数第三个项就是指向的 IAT 表，IMAGE_DIRECTORY_ENTRY_IAT，也是以0结束。在文件加载前，这两个表存的内容完全一致，都是存储的IMAGE_THUNK_DATA 结构（IMAGE_THUNK_DATA32）（详见下下图）。注意虽然一致，但 INT 表和 IAT 表是两块不同的空间，分别记录的都是程序中使用到的 dll 函数，不使用的 dll 函数不会记录。</p>
<p>PE文件加载前：<br><img src="/PE/202310191910.png" alt="202310191910"></p>
<p>​			</p>
<p>这里要注意的是，NTDLL和Kernel32会提前将函数地址放入IAT</p>
<p>上文提到的 IMAGE_THUNK_DATA 结构其实只是一个四字节的 union，如下图。</p>
<p>在加载前，IMAGE_THUNK_DATA 只存一个 RVA，这个 RVA 指向上图的IMAGE_IMPORT_BY_NAME 结构（具体结构格式在下图也有）</p>
<blockquote>
<p>在这个结构中，<code>BYTE Name[1];</code> 使用的技巧是所谓的 “结构体变长数组”，这种技巧通常用于存储可变长度的数据。尽管声明为 <code>BYTE Name[1];</code>，实际上这个字段可以容纳一个以 null 终止的字符串，而字符串的长度可以是任意的。</p>
<p>这是因为在PE文件的导入表中，函数名称并不是固定长度的，每个函数名称的长度都不同。因此，为了有效地存储这些不定长度的字符串，使用了变长数组的技巧。结构体只定义了一个字节的数组，但在实际使用时，根据函数名称的长度动态分配所需的内存，然后将函数名称存储在这个内存块中，以 null 终止字符串。</p>
<p>这种方法允许节省内存，因为不需要为每个结构分配固定大小的缓冲区以容纳字符串，而可以根据实际需要进行动态分配。在C&#x2F;C++中，这种技巧在很多情况下用于处理可变长度的数据，例如字符串数组，以提高内存使用效率。在实际使用时，程序员通常会动态分配足够的内存以存储实际的字符串，然后将字符串内容复制到该内存中，以确保字符串正确存储和 null 终止。</p>
</blockquote>
<p>在加载后，IAT 表变为存储函数的地址了，所以才有文章最前面提到的，在调用 MassageBox 文件加载前call间接寻址找的是一个字符串，而文件加载后这个间接寻址变为了函数的真正地址。而 INT 表不变。</p>
<p>IAT 表在文件加载完成后系统会调用 GetProcAddress() 函数，就是做的我们前面写过的根据导出表函数序号或函数名字找到函数地址的功能。系统会循环 INT 表，根据表内的名字或序号调用 GetProcAddr() 得到地址，依次添加到 IAT 表中。</p>
<p>注意 IMAGE_IMPORT_BY_NAME 中的 Hint 不是导出序号，而是当前这个函数在导出表函数地址表中的索引。但基本没用，所以不一定是准确的，可以全部为0。而Name并不是一字节，而是以’\0’结尾的不定长字符串。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_THUNK_DATA32</span> &#123;						</span><br><span class="line">    <span class="keyword">union</span> &#123;						</span><br><span class="line">        PBYTE  ForwarderString;						</span><br><span class="line">        PDWORD Function;						</span><br><span class="line">        DWORD Ordinal;						 <span class="comment">//序号</span></span><br><span class="line">        PIMAGE_IMPORT_BY_NAME  AddressOfData;<span class="comment">//指向IMAGE_IMPORT_BY_NAME</span></span><br><span class="line">    &#125; u1;						</span><br><span class="line">&#125; IMAGE_THUNK_DATA32;						</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;						</span><br><span class="line">						</span><br><span class="line">						</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_IMPORT_BY_NAME</span> &#123;						</span><br><span class="line">    WORD    Hint;						<span class="comment">//可能为空，编译器决定 如果不为空 是函数在导出表中的索引</span></span><br><span class="line">    BYTE    Name[<span class="number">1</span>];				    <span class="comment">//函数名称，以0结尾</span></span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;		</span><br></pre></td></tr></table></figure>

<p>哎，被一个基础的指针指向搞迷糊了，一个指针类型指向一个结构，取了星才是这个结构本身。</p>
<p>注意，IMAGE_IMPORT_BY_NAME 中的 Name 并不只有 1 个字节，而是一直遍历到元素为 ‘\0’ 为止，OriginalFirstThunk 和 FirstThunk 的遍历 具体详见下图（这俩的遍历都一样的，其实都是遍历的 IMAGE_THUNK_DATA）</p>
<p><img src="/PE/202310191913.png" alt="202310191913"></p>
<p><img src="/PE/202310191914.png" alt="202310191914"></p>
<p>下面就是定位导入表的过程：</p>
<p>第一层循环遍历所有导入表，以0结尾</p>
<p>第二层循环先处理OriginalFirstThunk，其中的表项IMAGE_THUNK_DATA32就当做一个DWORD 四字节数据处理即可，为0则表结束</p>
<p>表项IMAGE_THUNK_DATA32 有可能是个序号，也有可能是个偏移，根据图中说明来处理。</p>
<p>从测试的结果来看，INT表就算是没有，貌似也不会咋样，但是IAT表是一定要有的<br>因为就算INT表没有东西，也可以从IAT表拿Dll的名字</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(取出导入表一项，且不为全<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(Name==<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//退出循环，停止加载导入表</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">LoadLibrary</span>(Name);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(FirstThunk==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    导入表名称地址 = OriginalFirstThunk; <span class="comment">//INT地址</span></span><br><span class="line">    <span class="keyword">if</span>(OriginalFirstThunk==<span class="literal">NULL</span>)	<span class="comment">//如果INT为空，则转为拿IAT</span></span><br><span class="line">    &#123;</span><br><span class="line">        导入名称表地址=FirstThunk；		</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(从导入名称表获取一个名称地址)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(名称地址==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//结束遍历</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(名称地址最高位为<span class="number">1</span>)</span><br><span class="line">        &#123;	</span><br><span class="line">            <span class="comment">//序号导入</span></span><br><span class="line">            序号 = 名称地址 &amp; <span class="number">0xffff</span>;</span><br><span class="line">            导入函数地址=<span class="built_in">GetProcAddress</span>(序号);   </span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            导入函数地址 = <span class="built_in">GetProcAddress</span>(名称地址);</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        导入函数地址：填入 IAT对应项;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h1 id="绑定导入表："><a href="#绑定导入表：" class="headerlink" title="绑定导入表："></a>绑定导入表：</h1><p>（比较新的Windows版本基本废弃使用绑定导入表了  ）</p>
<p>1.关于绑定导入<br>一般情况下，在程序加载前IAT表和INT表中的内容相同，都是程序引用的dll中的函数的函数名或序号；<br>加载完成后IAT表中将替换为函数的真正地址；</p>
<p> 如果dll文件被更新了，那绑定导入表的时间戳和dll文件的时间戳就不一样了，内容肯定变了，就需要修正序号函数名称函数地址表，绑定导入表就这作用 </p>
<p>但在加载前IAT表中直接写绝对地址是可以实现的；<br>加载前在IAT表中保存绝对地址的优点：启动程序快；<br>在启动程序时需要：申请4gb内存空间、贴exe、贴dll、将IAT表修复为地址等等；<br>如果直接用绝对地址，则省去了修复IAT表的操作；<br>缺点：<br>dll重定位时，如果dll没能占据自身ImageBase处的地址，则需要修复绝对地址；<br>dll被修改时，dll被修改，IAT表中对应的函数地址可能被改，需要修复函数地址；</p>
<p>例如windows提供的一些程序就使用了这种方式，比如记事本；<br>这种方式称为“绑定导入“；</p>
<p>2.如何判断绑定导入<br>在导入表中结构中有个属性：TimeDateStamp；<br>该属性表示时间戳；<br>如果值为0则表示当前的dll的函数没有被绑定，在程序加载时会调用系统函数获取函数地址；<br>如果值为-1则表示当前的dll的函数已经绑定，而且绑定的时间存在另外一张表里；那张表就是绑定导入表；</p>
<p>3.绑定导入表<br>PE加载EXE相关的DLL时，首先会根据IMAGE_IMPORT_DESCRIPTOR结构中的TimeDateStamp来判断是否要重新计算IAT表中的地址。<br>TimeDateStamp &#x3D;&#x3D; 0 未绑定<br>TimeDateStamp &#x3D;&#x3D; -1 已绑定 真正的绑定时间为IMAGE_BOUND_IMPORT_DESCRIPTOR的TimeDateStamp</p>
<p>绑定导入表位于数据目录的第12项；<br>绑定导入表的结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_BOUND_IMPORT_DESCRIPTOR</span> &#123;</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    WORD    OffsetModuleName;</span><br><span class="line">    WORD    NumberOfModuleForwarderRefs;    <span class="comment">// Array of zero or more IMAGE_BOUND_FORWARDER_REF follows</span></span><br><span class="line">&#125; IMAGE_BOUND_IMPORT_DESCRIPTOR,  *PIMAGE_BOUND_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>

<p>TimeDateStamp -&gt;时间戳；用来判断是否和绑定的dll是同一个版本；也就是看时间戳和dll的pe头中的时间戳是否一样；<br>OffsetModuleName -&gt;dll的名字；注意保存的既不是RVA也不是FOA；<br>dll的名字计算公式为：第一个DESCRIPTOR的值+OffsetModuleName；<br>NumberOfModuleForwarderRefs -&gt;当前dll另外依赖的dll数量；因为dll也可能依赖dll；</p>
<p>绑定导入表结构后面紧跟的并不一定是下一个绑定导入表；<br>如果NumberOfModuleForwarderRefs为N则还有N个另外的结构；<br>该结构也是用来描述dll的；<br>结构如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_BOUND_FORWARDER_REF</span> &#123;</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    WORD    OffsetModuleName;</span><br><span class="line">    WORD    Reserved;</span><br><span class="line">&#125; IMAGE_BOUND_FORWARDER_REF, *PIMAGE_BOUND_FORWARDER_REF;</span><br></pre></td></tr></table></figure>

<p> 前两个属性和绑定导入表意义一样；<br>第三个属性Reserved为保留字段没鸟用<br>绑定导入表的结构图： </p>
<p><img src="/PE/202310211146.png" alt="202310211146"></p>
<p> 注意：<br>当IMAGE_BOUND_IMPORT_DESCRIPTOR结构中的TimeDateStamp与DLL文件标准PE头中的TimeDateStamp值不相符时，<br>或者DLL需要重新定位的时候，就会重新计算IAT中的值. </p>
<h1 id="导入表注入"><a href="#导入表注入" class="headerlink" title="导入表注入"></a>导入表注入</h1><p>凡是记录在导入表的dll，都会被系统加载到进程</p>
<p>步骤很简单：</p>
<p>1.找到一片宽阔的区域（没有存数据的区域）</p>
<p>2.把位于可选头存导入表的地址（注意时ROV）改到找到的没有存数据的区域</p>
<p>3.将原来的导入表复制到新的区域，</p>
<p>4.加上自己的导入表数据</p>
<p>按照下面这个来</p>
<p><img src="/PE/202310191910.png" alt="202310191910"></p>
<p>有个问题就是如果我用扫雷，发现注入不成功，原因未知<br>（已解决，属性要改下，最好每个节都给最高权限就不会有这些问题）</p>
<h1 id="LoadPE"><a href="#LoadPE" class="headerlink" title="LoadPE"></a>LoadPE</h1><p>已经写好了，放在E盘</p>
<p> [C_LoadPe.rar](E:\viusal studio document\科锐\PE\LoadPe\C_LoadPe.rar) </p>
<p>（前提：没有TLS表）</p>
<p>主要就是解决	导入表修复问题</p>
<p>因为LoadLibrary只是简单的把文件映射到内存，IAT表此时还是和INT表是一个东西，并没有填上真正的地址</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Stretch_Data.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    Stretch m_stretch;</span><br><span class="line">    m_stretch.<span class="built_in">GetContext</span>();</span><br><span class="line">    LPVOID PTR = <span class="built_in">VirtualAlloc</span>((LPVOID)<span class="number">0x400000</span>, <span class="number">0x30000</span>, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//拷贝DOS头 NT头 节表</span></span><br><span class="line">    <span class="built_in">memcpy</span>(PTR, m_stretch.Stretch_Pointer, <span class="built_in">sizeof</span>(IMAGE_DOS_HEADER) + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS) + m_stretch.PFile_Header-&gt;SizeOfOptionalHeader + m_stretch.PFile_Header-&gt;NumberOfSections * <span class="built_in">sizeof</span>(IMAGE_SECTION_HEADER));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拷贝各种节</span></span><br><span class="line">    LPVOID Temp_Ptr = m_stretch.Stretch_Pointer;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_stretch.PFile_Header-&gt;NumberOfSections; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>((LPVOID)((DWORD)PTR + m_stretch.Section[i].VirtualAddress), (LPVOID)((DWORD)Temp_Ptr+m_stretch.Section[i].PointerToRawData), m_stretch.Section[i].Misc.VirtualSize);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;拷贝结束！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//修复导入表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_stretch.Improt_Table_Num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        PIMAGE_THUNK_DATA m_ptr = (IMAGE_THUNK_DATA*)((DWORD)PTR + (DWORD)m_stretch.Import_Table[i].OriginalFirstThunk);</span><br><span class="line">        INT COUNT = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            DWORD Number = <span class="number">0</span>;</span><br><span class="line">            CHAR* Func_Name = <span class="number">0</span>;</span><br><span class="line">            CHAR* Dll_Name;</span><br><span class="line">            Dll_Name = (CHAR*)((DWORD)PTR + m_stretch.Import_Table[i].Name);</span><br><span class="line">            <span class="keyword">if</span> (m_ptr-&gt;u1.Ordinal &amp; <span class="number">0x80000000</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Number = m_ptr-&gt;u1.Ordinal;</span><br><span class="line">                HMODULE handle = <span class="built_in">LoadLibrary</span>(Dll_Name);</span><br><span class="line">                DWORD FuncAddr = (DWORD)<span class="built_in">GetProcAddress</span>(handle, (<span class="type">char</span>*)Number);</span><br><span class="line">                DWORD* IAT = (DWORD*)(m_stretch.Import_Table[i].FirstThunk + (DWORD)PTR + COUNT * <span class="number">4</span>);</span><br><span class="line">                *IAT = FuncAddr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Func_Name = (CHAR*)((DWORD)PTR + (DWORD)m_ptr-&gt;u1.AddressOfData + <span class="number">0x2</span>);</span><br><span class="line">                HMODULE handle = <span class="built_in">LoadLibrary</span>(Dll_Name);</span><br><span class="line">                DWORD FuncAddr = (DWORD)<span class="built_in">GetProcAddress</span>(handle, (<span class="type">char</span>*)Func_Name);</span><br><span class="line">                DWORD* IAT = (DWORD*)(m_stretch.Import_Table[i].FirstThunk + (DWORD)PTR + COUNT * <span class="number">4</span>);</span><br><span class="line">                *IAT = FuncAddr;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            COUNT++;</span><br><span class="line">            m_ptr = (PIMAGE_THUNK_DATA)((DWORD)m_ptr + <span class="built_in">sizeof</span>(IMAGE_THUNK_DATA));</span><br><span class="line">            <span class="keyword">if</span> (m_ptr-&gt;u1.AddressOfData == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        mov eax,<span class="number">0x411023</span></span><br><span class="line">        jmp eax</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h1 id="导出表："><a href="#导出表：" class="headerlink" title="导出表："></a>导出表：</h1><p><strong>按照序号导出的时候：</strong></p>
<p>导出表存的不是下面这个形式：</p>
<table>
<thead>
<tr>
<th>索引</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>0x11223344</td>
</tr>
<tr>
<td>2</td>
<td>0x44556677</td>
</tr>
<tr>
<td>3</td>
<td>0x11223366</td>
</tr>
</tbody></table>
<p>导入表是没有索引的，直接存地址：</p>
<table>
<thead>
<tr>
<th>0x11223344</th>
</tr>
</thead>
<tbody><tr>
<td>0x11223344</td>
</tr>
<tr>
<td>0x55661122</td>
</tr>
</tbody></table>
<p>那没有索引咋定位呢？回存一个base</p>
<p>例如第一个编码是0x1000，第二个是0x1001，第三个是0x1002</p>
<p>那么base就是0x1000，然后按照顺序存，例如0x1000就存在第0个，0x1002就存在第二个</p>
<p>当然如果编码分别是0x1000,0x2000,0x3000</p>
<p>那么base仍然是0x1000，序号为0x2000的与0x1000的中间会隔着0x1000的空数据</p>
<p><strong>这就是空间换时间</strong></p>
<p>如果是名称导出，系统自动给名称编个序号，本质上也是根据序号去找</p>
<p> 数据目录结构 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">IMAGE_DIRECTIRY_ENTRY_EXPORT</span> &#123;</span><br><span class="line">    DWORD   VirtualAddress;		<span class="comment">//RVA地址</span></span><br><span class="line">    DWORD   Size;				<span class="comment">//该数据所占的大小。可以修改（函数转发的判断条件）</span></span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure>

<p><img src="/PE/1714032068741.png" alt="1714032068741"></p>
<p><strong>IMAGE_EXPORT_DIRECTORY</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_EXPORT_DIRECTORY</span> &#123;</span><br><span class="line">  +<span class="number">0</span>   DWORD   Characteristics;        	<span class="comment">// 属性，可修改		</span></span><br><span class="line">  +<span class="number">4</span>   DWORD   TimeDateStamp;          	<span class="comment">// 时间，可修改</span></span><br><span class="line">  +<span class="number">8</span>   WORD    MajorVersion;           	<span class="comment">// 版本，可修改</span></span><br><span class="line">  +a   WORD    MinorVersion;           	<span class="comment">// 版本，可修改</span></span><br><span class="line">  +c   DWORD   Name;                   	<span class="comment">// 库名称，可修改</span></span><br><span class="line">  +<span class="number">10</span>  DWORD   Base;                   	<span class="comment">// 序号基址</span></span><br><span class="line">  +<span class="number">14</span>  DWORD   NumberOfFunctions;		<span class="comment">// 导出函数个数</span></span><br><span class="line">  +<span class="number">18</span>  DWORD   NumberOfNames;			<span class="comment">// 导出名称表个数</span></span><br><span class="line">  +<span class="number">1</span>c  DWORD   AddressOfFunctions;     	<span class="comment">// 导出函数地址表 RVA</span></span><br><span class="line">  +<span class="number">20</span>  DWORD   AddressOfNames;         	<span class="comment">// 导出函数名称表 RVA</span></span><br><span class="line">  +<span class="number">24</span>  DWORD   AddressOfNameOrdinals;  	<span class="comment">// 导出函数序号表 RVA</span></span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure>





<p><img src="/PE/1714032104841.png" alt="1714032104841"></p>
<p>AddressOfFunctions 存的是导出函数的地址</p>
<p>AddressOfNames	指的是按照名字导出的函数的个数</p>
<p>AddressOfNameOrdinals 	指的是按照名字导出的序号表，序号个数和NumberOfNames是一致的</p>
<p><strong>那么不按序号导出的情况时，序号个数不是和NumberOfNames相等吗？难道不按序号导出就不配拥有序号？</strong></p>
<p>当然不是，序号还是会有的，去AddressOfFunctions去找，对应的索引加上Base就是对应的序号值</p>
<p>a. 导出函数地址表：</p>
<ul>
<li>该表中元素宽度为4个字节</li>
<li>该表中存储所有导出函数的地址</li>
<li>该表中个数由NumberOfFunctions决定</li>
<li>该表项中的值是RVA，需要加上ImageBase才是函数真正的地址。</li>
</ul>
<p>b. 导出函数名称表：</p>
<ul>
<li>该表中的元素宽度为4个字节。</li>
<li>该表中存储所有以名字导出函数的名字的RVA（以 &#x2F;0结尾的字符串）</li>
<li>导出名称表是排序过的，有利于折半查找。（ASCLL码排序）</li>
</ul>
<p>c. 导出函数序号表：</p>
<ul>
<li>该表中的元素是2个字节</li>
<li>该表中存储的是对应函数地址表的下标。</li>
<li>该表中个数由导出序号的最大值 - 最小值 决定，没有的序号内容以 NULL 填充（所以会造成如果序号值相差过大，会影响Dll的体积）</li>
</ul>
<p><strong>（三）为什么分成3张表？</strong></p>
<ol>
<li>函数导出的个数与函数名个数未必一样，所以需要将导出函数地址和导出函数名称表分开。</li>
<li>函数地址表并不是一定大于函数名称表的。因为一个相同的函数可能存在多个不同的名字。</li>
</ol>
<h2 id="模拟GetProcAddress"><a href="#模拟GetProcAddress" class="headerlink" title="模拟GetProcAddress"></a>模拟GetProcAddress</h2><p><strong>重要性</strong>：加壳的代码很容易被人dump，因此为了防御都会想办法抹除导入表，内存和文件中都没有。</p>
<p>但是程序运行起来的时候，总要加载所需DLL，攻击者会在GetProcAddress下断点，将每次的数据都保存下来，从而恢复导入表。</p>
<p>但是，如果这个函数以及内部完全由自己实现的话，攻击者就不得不看代码进行还原。</p>
<p>反Dump：目前很多防止Dump都使用了API模拟，不调用API，将IAT表填上自己模拟的API地址。</p>
<p>原理：根据模块句柄和函数的名称或则序号来获取该API所在的地址。</p>
<p><strong>（一）步骤：</strong></p>
<ol>
<li>定位到导出名称表</li>
<li>获取导出名称表个数</li>
<li>遍历比较字符串</li>
<li>获取对应的序号</li>
<li>获取序号对应的地址，（从地址表中获取）</li>
</ol>
<p>（二）函数转发处理</p>
<p>判断转发函数：判断获取到的函数地址表地址是否在 导入名称表 + 导出表Size （导出表）范围内</p>
<p><img src="/PE/1714033738638.png" alt="1714033738638">	</p>
<p>处理流程：</p>
<ol>
<li>拆解字符串。LoadLibaray（DLL名称）</li>
<li>调用自己，获取名字的地址。</li>
</ol>
<h2 id="导出表应用"><a href="#导出表应用" class="headerlink" title="导出表应用"></a>导出表应用</h2><p><strong>（一）IAT表反向查询</strong></p>
<p>VA（内存中的call地址） &#x3D;&gt; RVA(转换成基于当前模块的偏移地址) &#x3D;&gt; 遍历模块() &#x3D;&gt;遍历导出表 &#x3D;&gt; 遍历导出地址表，判断RVA是否命中 &#x3D;&gt;遍历序号表 &#x3D;&gt;从名称表获取函数名称</p>
<p>不用考虑函数转发问题，因为函数转发的地址会命中另一个模块</p>
<p>静态反汇编只能看导入表，动态调试才能查看导出表</p>
<p><strong>（二）IDA显示函数名称</strong></p>
<p>​	通过导入表反向查询函数名称，如果将PE文件中导入函数名称表中的地址按照计划调换位置，然后动态运行时再通过内存访问换回来，那么IDA作为静态调试只能通过PE中记录的函数名称去导入表信息遍历，这样只能获取错误的API。</p>
<p>​	IAT被填入了错误的API地址，而IDA进行IAT反向查询，实际上显示的是正确的，但是运行时程序会调用修改后的API。</p>
<p>​	可以选用参数个数相同，但是功能不同的API，攻击者使用IDA反汇编看到的汇编代码调用了一个API，但实际上程序的调用了是另一个API，起到了混淆的作用。</p>
<p>​	这样实际上就是对IDA做反汇编对抗，IDA没有办法检查API的正确性。</p>
<h1 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h1><p>在数据目录表的第五个（从0开始算）</p>
<p><strong>简介：</strong></p>
<p>定义：记录需要<strong>绝对地址修正</strong>的表，大多数绝对地址如果imagebase变化的话就无法使用，需要修正程序所调用的那些绝对地址。</p>
<ul>
<li><p><strong>修正方法：需要重定位的地址 + 偏移（当前基址 - PE的基址）</strong></p>
</li>
<li><p>开了随机基址的程序才需要重定位，而DLL通常都有重定位表，因为不一定能够加载到DLL指定的ImageBase上。</p>
</li>
</ul>
<p><strong>为什么需要重定位呢？不是已经有导出表了，里面就有函数的偏移呀</strong></p>
<p>因为导出表里面记录的偏移，也就是AddressOfFunctions，不包含dll里面不导出的函数地址，仅仅只有导出函数的地址，如果没有重定位表，那么这些地址将得不到修正，在dll也就无法调用这些不导出的函数，会影响Dll的正常功能</p>
<p>修的应该是那些绝对地址的，重定位表会指出需要修改的机器码的地址，然后修改即可，会改变机器码</p>
<p><strong>OS如何判定是否重定位？</strong></p>
<ul>
<li>先查看随机地址标志，标志开启，地址重定位</li>
<li>再查看数据目录项 5 是否位NULL，不为NULL，基址重定位。</li>
</ul>
<h2 id="重定位表结构"><a href="#重定位表结构" class="headerlink" title="重定位表结构"></a>重定位表结构</h2><p>重定位表描述待修复的值所在的地方，这个值是一个RVA。数据目录处的Size字段有用，是重定位表的总大小。</p>
<p>重定位表位于数据目录第3项。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_BASE_RELOCATION</span> &#123;</span><br><span class="line">    DWORD   VirtualAddress;		<span class="comment">//重定位数据所在页的RVA</span></span><br><span class="line">    DWORD   SizeOfBlock;		<span class="comment">//当前页中重定位数据块的总大小</span></span><br><span class="line"><span class="comment">//  WORD    TypeOffset[1];		//重定位项数组</span></span><br><span class="line">&#125; IMAGE_BASE_RELOCATION;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>VirtualAddress</p>
</li>
<li><ul>
<li>这个虚拟地址是一组重定位数据的开始RVA地址，只有重定位项的有效数据加上这个值才是重定位数据真正的RVA地址</li>
</ul>
</li>
<li><p>SizeOfBlock</p>
</li>
<li><ul>
<li>它是当前重定位块的总大小，因为VirtualAddress和SizeOfBlock都是4字节的，所以(SizeOfBlock - 8)才是该块所有重定位项的大小，(SizeOfBlock - 8) &#x2F; 2就是该块所有重定位项的数目。</li>
</ul>
</li>
<li><p>TypeOffset[1]</p>
</li>
<li><ul>
<li>重定位项在该结构中没有体现出来，他的位置是紧挨着这个结构的，可以把他当作一个数组，宽度为2字节。表示该地址处有一个地址需要进行重定位</li>
<li>每一个重定位项分为两个部分：高4位和低12位</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>高4位表示了重定位数据的类型(0x00没有任何作用仅仅用作数据填充，为了4字节对齐,说明这个地址不需要修正。0x03表示这个数据是重定位数据，需要修正。0x0A出现在64位程序中，也是需要修正的地址)，</li>
<li>低12位就是重定位数据相对于VirtualAddress的偏移，也就是上面所说的有效数据。之所以是12位，是因为12位的大小足够表示该块中的所有地址(每一个数据块表示一个页中的所有重定位数据，一个页的大小位0x1000)。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>修正方法：被重定位处原来的地址 + 偏移（当前基址 - PE的基址）：（VA - ImageBase） + NewImageBase</strong></p>
<p>重定位表只是记录了修哪里，以及怎么修，并不会记录修多少，因为既然是随机基址，那么基址的值就不固定，必须每次软件起来才能确定。</p>
<p><img src="/PE/1714049885702.png" alt="1714049885702"></p>
<p> <img src="https://cdn.nlark.com/yuque/0/2022/png/5360235/1646895204762-09569316-666d-433c-bfe8-c1f2e6f77674.png?x-oss-process=image/format,webp/resize,w_1039,limit_0" alt="image.png"> </p>
<p><strong>注意：</strong>.<strong>reloc：</strong> 的节一般用于存储重定位表，但是不作为定位重定位表的依据，应使用数据目录定位。</p>
<p><img src="/PE/1714054461924.png" alt="1714054461924"></p>
<p>这个讲得不清不楚的，但是还是要说一下，并不是因为IAT表里面的地址需要被修正，而是调用某函数的时候，会先要FF 15 Call到IAT表，然后再Call IAT表里面真正的函数地址</p>
<p><img src="/PE/1714054793352.png" alt="1714054793352"></p>
<p>所以 FF 15 Call的 IAT表的地址需要被修正</p>
<p>学完壳，再回来看看，感觉好奇怪</p>
<p><img src="/PE/1714057549608.png" alt="1714057549608"></p>
<h1 id="TLS表"><a href="#TLS表" class="headerlink" title="TLS表"></a>TLS表</h1><p>TLS:	Thread local storage  线程局部存储</p>
<h2 id="显式TLS："><a href="#显式TLS：" class="headerlink" title="显式TLS："></a>显式TLS：</h2><p>用Windows提供的API</p>
<ol>
<li><code>TlsAlloc</code>:<ul>
<li>函数原型：<code>DWORD TlsAlloc(void);</code></li>
<li>功能：分配一个新的 TLS 索引，该索引可用于在当前进程的所有线程中访问线程局部存储。</li>
<li>返回值：如果成功，则返回一个 TLS 索引；如果失败，则返回 <code>TLS_OUT_OF_INDEXES</code> (-1)。</li>
<li>示例用法：通常在程序初始化时调用 <code>TlsAlloc</code> 来分配一个 TLS 索引，然后将该索引保存在全局变量中以备后续使用。</li>
</ul>
</li>
<li><code>TlsSetValue</code>:<ul>
<li>函数原型：<code>BOOL TlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue);</code></li>
<li>功能：将数据存储到当前线程的指定 TLS 索引处。</li>
<li>参数：<ul>
<li><code>dwTlsIndex</code>：要设置值的 TLS 索引。</li>
<li><code>lpTlsValue</code>：要存储的数据指针。</li>
</ul>
</li>
<li>返回值：如果成功，则返回非零值；如果失败，则返回零。</li>
<li>示例用法：在当前线程中调用 <code>TlsSetValue</code> 来存储线程私有数据。</li>
</ul>
</li>
<li><code>TlsGetValue</code>:<ul>
<li>函数原型：<code>LPVOID TlsGetValue(DWORD dwTlsIndex);</code></li>
<li>功能：从当前线程的指定 TLS 索引处获取数据。</li>
<li>参数：<ul>
<li><code>dwTlsIndex</code>：要获取值的 TLS 索引。</li>
</ul>
</li>
<li>返回值：如果成功，则返回存储在 TLS 索引处的数据指针；如果失败，则返回 <code>NULL</code>。</li>
<li>示例用法：在当前线程中调用 <code>TlsGetValue</code> 来获取之前存储的线程私有数据。</li>
</ul>
</li>
<li><code>TlsFree</code>:<ul>
<li>函数原型：<code>BOOL TlsFree(DWORD dwTlsIndex);</code></li>
<li>功能：释放指定的 TLS 索引。</li>
<li>参数：<ul>
<li><code>dwTlsIndex</code>：要释放的 TLS 索引。</li>
</ul>
</li>
<li>返回值：如果成功，则返回非零值；如果失败，则返回零。</li>
<li>示例用法：在程序退出或不再需要某个 TLS 索引时调用 <code>TlsFree</code> 来释放该索引。</li>
</ul>
</li>
</ol>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD dwVal=(DWORD)<span class="built_in">TlsGetValue</span>(<span class="number">0</span>);</span><br><span class="line">	cout &lt;&lt; hex &lt;&lt; dwVal &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">TlsSetValue</span>(<span class="number">1</span>, (LPVOID)<span class="number">0x1111111111</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">TlsSetValue</span>(<span class="number">0</span>,(LPVOID)<span class="number">0x12345678</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function">thread <span class="title">t</span><span class="params">(ThreadFunc)</span></span>;</span><br><span class="line">	t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">	DWORD dwVal = (DWORD)<span class="built_in">TlsGetValue</span>(<span class="number">0</span>);</span><br><span class="line">	cout &lt;&lt; hex &lt;&lt; dwVal &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*在 Windows 中，TLS 索引在第一次调用 TlsSetValue 函数时会自动分配。因此，尽管你在代码中没有显式调用 TlsAlloc 函数来分配 TLS 索引，但在调用 TlsSetValue(0, (LPVOID)0x12345678); 时，系统会自动为 TLS 索引分配一个值为 0 的 TLS 索引，并将值 0x12345678 存储到该索引处。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">所以，即使你没有显式地调用 TlsAlloc，仍然可以使用 TlsSetValue 和 TlsGetValue 来操作 TLS。但是显式地调用 TlsAlloc 可以提供更明确的控制和可读性，特别是在需要多个 TLS 索引时。*/</span></span><br></pre></td></tr></table></figure>



<p><img src="/PE/1714136965265.png" alt="1714136965265"></p>
<p>从运行的结果可以知道，主线程调用的TlsSetValue的值不能被子线程读到，同理，子线程设的值也不会被主线程读到</p>
<p>我们来看看，TlsSetValue是怎么干活的</p>
<p>[ebp+0x8]是第二个参数，[ebp+0xC]是第一个参数</p>
<p><img src="/PE/1714138082207.png" alt="1714138082207"></p>
<p>发现把eax，也就是第二个参数，丢进了dword ptr[edi+esi*4+0xE10]，edi是fs:[0x18] （即TEB）</p>
<p>用Windbg查出来，+0xE10存的是TlsSlots</p>
<p><img src="/PE/1714138441720.png" alt="1714138441720"></p>
<p>发现是一个DWORD的，有64个元素的数组</p>
<p> <strong>TLS是用来存啥的？如果是TlsSlots是DWORD数组，那可以存字符串吗</strong> </p>
<p>在 Windows 中，TLS 可以用来存储各种类型的数据，包括整数、指针、结构体等。TLS 通常被用于存储线程特定的数据或者线程需要独立访问的数据，比如线程相关的配置信息、状态信息、线程私有的全局变量等。</p>
<p>（超过四字节就存地址呗 ）</p>
<p> <code>TlsAlloc</code> 函数的作用是在 TLS (Thread Local Storage) 索引数组中找到一个空闲的位置，并返回该位置的索引值。 </p>
<h2 id="隐式TLS："><a href="#隐式TLS：" class="headerlink" title="隐式TLS："></a>隐式TLS：</h2><p>变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__declspec(thread) DWORD g_dwVal = <span class="number">0x12345678</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; g_dwVal &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; g_dwVal &lt;&lt; endl;</span><br><span class="line">	g_dwVal = <span class="number">0x111111</span>;</span><br><span class="line">	<span class="function">thread <span class="title">t</span><span class="params">(ThreadFunc)</span></span>;</span><br><span class="line">	t.<span class="built_in">join</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/PE/1714140178291.png" alt="1714140178291"></p>
<p>发现主线程是可以读取的，但是不能改变</p>
<p>为啥会这样呢，我们用汇编看看怎么个事</p>
<p>对应着这个</p>
<p>g_dwVal &#x3D; 0x111111;</p>
<p><img src="/PE/1714140398129.png" alt="1714140398129"></p>
<p><img src="/PE/1714141124330.png" alt="1714141124330"></p>
<p>大概长这样，随便画的</p>
<p><img src="/PE/1714141343861.png" alt="1714141343861"></p>
<p>0x104是一个定死的值，具体为啥，没说</p>
<p>TLS表：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_TLS_DIRECTORY32</span> &#123;</span><br><span class="line">    DWORD   StartAddressOfRawData; 	<span class="comment">// 隐式TLS变量初始化值存储范围的 起始地址(VA)</span></span><br><span class="line">    DWORD   EndAddressOfRawData;	<span class="comment">// 隐式TLS变量初始化值存储范围的 结束地址(VA)</span></span><br><span class="line">    DWORD   AddressOfIndex;         <span class="comment">// 索引 （上面的_tls_index）</span></span><br><span class="line">    DWORD   AddressOfCallBacks;     <span class="comment">// 回调函数的地址（可以填多个，每个都会调用）</span></span><br><span class="line">    DWORD   SizeOfZeroFill;         <span class="comment">//</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DWORD Characteristics;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            DWORD Reserved0 : <span class="number">20</span>;</span><br><span class="line">            DWORD Alignment : <span class="number">4</span>;</span><br><span class="line">            DWORD Reserved1 : <span class="number">8</span>;</span><br><span class="line">        &#125; DUMMYSTRUCTNAME;</span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">&#125; IMAGE_TLS_DIRECTORY32;</span><br></pre></td></tr></table></figure>



<p><strong>PE头里面的 TLS 表，使用隐式TLS的时候才存在该表，数据目录第 9（下标） 项</strong></p>
<p><strong>StartAddressOfRawData</strong> 和 <strong>EndAddressOfRawData</strong> 决定一个范围，创建线程的时候拷贝该范围数据到TEB结构体中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__declspec(thread) DWORD g_dwVal = <span class="number">0x12345678</span>;</span><br></pre></td></tr></table></figure>

<p>加了一句这个，编译器就会在PE中留一块内存，专门存放这玩意</p>
<p>当进程启动后，就会拷贝到TEB，然后自己去TEB里面拿，TEB是每个线程独有的</p>
<p>这样就能保证每个线程都只能操控自己的变量</p>
<p>总结就是： tls就是把pe的tls数据复制到线程结构体里，没了</p>
<h2 id="TLS-Callback-TLS回调函数"><a href="#TLS-Callback-TLS回调函数" class="headerlink" title="TLS_Callback TLS回调函数"></a>TLS_Callback TLS回调函数</h2><p><strong>TLS_Callback</strong></p>
<p>TLS_Callback（Thread-local storage，线程本地存储）是WindowsAPI下的一个回调函数，它会在程序进程开始，结束以及线程开始，结束的时候调用。</p>
<p><strong>TLS在逆向中</strong></p>
<p> TLS_Callback在逆向中有一个特点： 先于main函数执行&#x2F;在main结束后执行。因此也经常被用作反调试，或者是藏匿变量修改，以防止动态和静态分析。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment (linker, <span class="string">&quot;/INCLUDE:_tls_used&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment (linker, <span class="string">&quot;/INCLUDE:thread_callback_base&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment (linker, <span class="string">&quot;/INCLUDE:__tls_used&quot;</span>)	<span class="comment">//创建TLS表</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment (linker, <span class="string">&quot;/INCLUDE:_thread_callback_base&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">generate_str</span><span class="params">(<span class="type">char</span>* ptr, DWORD reason)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (reason) &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        <span class="built_in">strcat_s</span>(ptr ,<span class="number">200</span>, <span class="string">&quot;DLL_PROCESS_ATTACH\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="built_in">strcat_s</span>(ptr, <span class="number">200</span>, <span class="string">&quot;DLL_PROCESS_DETACH\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">        <span class="built_in">strcat_s</span>(ptr, <span class="number">200</span>, <span class="string">&quot;DLL_THREAD_ATTACH\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">        <span class="built_in">strcat_s</span>(ptr, <span class="number">200</span>, <span class="string">&quot;DLL_THREAD_DETACH\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TLS回调</span></span><br><span class="line"><span class="function"><span class="type">void</span> NTAPI <span class="title">tls_callback_1</span><span class="params">(PVOID DllHandle, DWORD Reason, PVOID Reserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hStdout = <span class="built_in">GetStdHandle</span>(STD_OUTPUT_HANDLE);</span><br><span class="line">    <span class="type">char</span> ptr[<span class="number">256</span>]&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">strcpy_s</span>(ptr, <span class="string">&quot;    TLS Callback1: &quot;</span>);</span><br><span class="line">    <span class="built_in">generate_str</span>(ptr, Reason);</span><br><span class="line">    <span class="built_in">WriteConsoleA</span>(hStdout, ptr, <span class="built_in">strlen</span>(ptr), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TLS回调</span></span><br><span class="line"><span class="function"><span class="type">void</span> NTAPI <span class="title">tls_callback_2</span><span class="params">(PVOID DllHandle, DWORD Reason, PVOID Reserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hStdout = <span class="built_in">GetStdHandle</span>(STD_OUTPUT_HANDLE);</span><br><span class="line">    <span class="type">char</span> ptr[<span class="number">256</span>]&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">strcpy_s</span>(ptr, <span class="string">&quot;    TLS Callback2: &quot;</span>);</span><br><span class="line">    <span class="built_in">generate_str</span>(ptr, Reason);</span><br><span class="line">    <span class="built_in">WriteConsoleA</span>(hStdout, ptr, <span class="built_in">strlen</span>(ptr), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> const_seg(<span class="string">&quot;.CRT$XLF&quot;</span>)</span></span><br><span class="line">EXTERN_C <span class="type">const</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> data_seg(<span class="string">&quot;.CRT$XLF&quot;</span>)</span></span><br><span class="line">EXTERN_C</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">PIMAGE_TLS_CALLBACK thread_callback_base[] = &#123; tls_callback_1, tls_callback_2, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> const_seg()</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> data_seg()</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//_WIN64</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK_PRINT_FLAG(s) (<span class="string">&quot;\033[1;40;32m[+]\033[0m &quot;</span>##s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERR_PRINT_FLAG(s) (<span class="string">&quot;\033[1;40;31m[-]\033[0m &quot;</span>##s)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程回调</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">thread_func</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ LPVOID lpParameter</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="built_in">OK_PRINT_FLAG</span>(<span class="string">&quot;Enter thread func...\n&quot;</span>));</span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">5000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="built_in">OK_PRINT_FLAG</span>(<span class="string">&quot;Leave thread func...\n&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="built_in">OK_PRINT_FLAG</span>(<span class="string">&quot;Enter main...\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">    HANDLE hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, thread_func, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(hThread, INFINITE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="built_in">OK_PRINT_FLAG</span>(<span class="string">&quot;Leave main...\n&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p>如何跟踪 Tls回调函数？？</p>
<p>我们跟踪到Tls表</p>
<p>根据前面提到的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_TLS_DIRECTORY32</span> &#123;</span><br><span class="line">    DWORD   StartAddressOfRawData; 	<span class="comment">// 隐式TLS变量初始化值存储范围的 起始地址(VA)</span></span><br><span class="line">    DWORD   EndAddressOfRawData;	<span class="comment">// 隐式TLS变量初始化值存储范围的 结束地址(VA)</span></span><br><span class="line">    DWORD   AddressOfIndex;         <span class="comment">// 索引 （上面的_tls_index）</span></span><br><span class="line">    DWORD   AddressOfCallBacks;     <span class="comment">// 回调函数的地址（可以填多个，每个都会调用）</span></span><br><span class="line">    DWORD   SizeOfZeroFill;         <span class="comment">//</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DWORD Characteristics;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            DWORD Reserved0 : <span class="number">20</span>;</span><br><span class="line">            DWORD Alignment : <span class="number">4</span>;</span><br><span class="line">            DWORD Reserved1 : <span class="number">8</span>;</span><br><span class="line">        &#125; DUMMYSTRUCTNAME;</span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">&#125; IMAGE_TLS_DIRECTORY32;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//对我们来说，有用的就前面四个</span></span><br></pre></td></tr></table></figure>



<p>对应的AddressOfCallBacks为0x417720，这是一个（VA）地址，我们直接用IDA去跟</p>
<p><img src="/PE/1714270322100.png" alt="1714270322100"></p>
<p>果然发现了回调函数数组</p>
<p><img src="/PE/1714270398892.png" alt="1714270398892"></p>
<h1 id="资源表："><a href="#资源表：" class="headerlink" title="资源表："></a>资源表：</h1><h2 id="解析资源表"><a href="#解析资源表" class="headerlink" title="解析资源表"></a>解析资源表</h2><p>这是一个嵌套的结构</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//资源目录头</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_RESOURCE_DIRECTORY</span> &#123;</span><br><span class="line">    DWORD   Characteristics;		</span><br><span class="line">    DWORD   TimeDateStamp;	</span><br><span class="line">    WORD    MajorVersion;</span><br><span class="line">    WORD    MinorVersion;</span><br><span class="line">    WORD    NumberOfNamedEntries;   <span class="comment">// 以字符串命名的资源的个数</span></span><br><span class="line">    WORD    NumberOfIdEntries;		<span class="comment">// 以ID命名的资源的个数</span></span><br><span class="line"><span class="comment">//  IMAGE_RESOURCE_DIRECTORY_ENTRY DirectoryEntries[]; 柔性数组，个数 = NumberOfNamedEntries + NumberOfIdEntries</span></span><br><span class="line">&#125; IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;</span><br><span class="line"></span><br><span class="line"><span class="comment">//资源的命名方式：1. 宏定义ID   2. 字符串命名</span></span><br><span class="line"><span class="comment">//当进行到第三层，IMAGE_RESOURCE_DIRECTORY_ENTRY DirectoryEntries[]中的第一个Union是一个代码页，我做实验发现是0x804</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//资源目录</span></span><br><span class="line">IMAGE_RESOURCE_DIRECTORY_ENTRY</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_RESOURCE_DIRECTORY_ENTRY</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            DWORD NameOffset:<span class="number">31</span>;    <span class="comment">// 节内偏移，指向</span></span><br><span class="line">            DWORD NameIsString:<span class="number">1</span>;   <span class="comment">//1：说明ID是字符串。</span></span><br><span class="line">        &#125; DUMMYSTRUCTNAME;</span><br><span class="line">        DWORD   Name;	<span class="comment">//</span></span><br><span class="line">        WORD    Id;		<span class="comment">//</span></span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    <span class="comment">//在这个union DWORD中最高位为1，那么就是说明ID是字符串，NameOffset指向字符串的偏移，否则，说明ID不是字符串，是一个数组，DWORD本身就是资源的ID值</span></span><br><span class="line">    <span class="comment">//其中指向的字符串的结构为	_IMAGE_RESOURCE_DIRECTORY_STRING</span></span><br><span class="line">     <span class="comment">//1. Name，这个字段拥有多个不同的含义：当IRDE位于第一层目录时，Name表示资源的类型；当IRDE位于第二层目录时，Name表示资源的名称；当IRDE位于第三层目录时，Name表示代码页的编号。此外，还需要先判断Name的最高位是0还是1，如果是0则表示当做一个值来使用，如果是1，则表示低31位当做指针来使用；</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DWORD   OffsetToData;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            DWORD   OffsetToDirectory:<span class="number">31</span>;</span><br><span class="line">            DWORD   DataIsDirectory:<span class="number">1</span>; <span class="comment">//1. 目录项，低位节内偏移。 0.数据，是一个文件，按照IMAGE_RESOURCE_DATA_ENTRY结构体解析</span></span><br><span class="line">        &#125; DUMMYSTRUCTNAME2;</span><br><span class="line">    &#125; DUMMYUNIONNAME2;</span><br><span class="line">&#125; IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二个union是用来判断是文件还是文件夹，也是看最高位，如果最高位为1，则为文件夹，那么偏移的地址的结构就是_IMAGE_RESOURCE_DIRECTORY。如果最高位为0，则是一个文件，那么按照_IMAGE_RESOURCE_DATA_ENTRY结构进行解析</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Pasc字符串</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_RESOURCE_DIRECTORY_STRING</span> &#123;</span><br><span class="line">    WORD    Length;</span><br><span class="line">    CHAR    NameString[ <span class="number">1</span> ];</span><br><span class="line">&#125; IMAGE_RESOURCE_DIRECTORY_STRING, *PIMAGE_RESOURCE_DIRECTORY_STRING;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@[comment(&quot;MVI_tracked&quot;)]</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_RESOURCE_DATA_ENTRY</span> &#123;</span><br><span class="line">    DWORD   OffsetToData;	<span class="comment">// 位置：RVA</span></span><br><span class="line">    DWORD   Size;			<span class="comment">// 资源的大小</span></span><br><span class="line">    DWORD   CodePage;</span><br><span class="line">    DWORD   Reserved;</span><br><span class="line">&#125; IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//前面四个元素都是没啥用的</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>我们来试着解析一波资源表：</p>
<p><img src="/PE/1714273648235.png" alt="1714273648235"></p>
<p>就以这个程序为例子：</p>
<p><img src="/PE/1714273752238.png" alt="1714273752238"></p>
<p>从9A00开始，就是资源表</p>
<p>前面0xC个字节对我们来说不重要</p>
<p>NumberOfNamedEntries;在这里是0，NumberOfIdEntries在这里是7</p>
<p>接下来是柔性数组，是_IMAGE_RESOURCE_DIRECTORY_ENTRY结构</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_RESOURCE_DIRECTORY_ENTRY</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_RESOURCE_DIRECTORY_ENTRY</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            DWORD NameOffset:<span class="number">31</span>;    <span class="comment">// 节内偏移，指向</span></span><br><span class="line">            DWORD NameIsString:<span class="number">1</span>;   <span class="comment">//1：说明ID是字符串。</span></span><br><span class="line">        &#125; DUMMYSTRUCTNAME;</span><br><span class="line">        DWORD   Name;	<span class="comment">//</span></span><br><span class="line">        WORD    Id;		<span class="comment">//</span></span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    <span class="comment">//在这个union DWORD中最高位为1，那么就是说明ID是字符串，NameOffset指向字符串的偏移，否则，说明ID不是字符串，是一个数组，DWORD本身就是资源的ID值</span></span><br><span class="line">    <span class="comment">//其中指向的字符串的结构为	_IMAGE_RESOURCE_DIRECTORY_STRING</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DWORD   OffsetToData;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            DWORD   OffsetToDirectory:<span class="number">31</span>;</span><br><span class="line">            DWORD   DataIsDirectory:<span class="number">1</span>; <span class="comment">//1. 目录项，低位节内偏移。 0.数据，是一个文件，按照IMAGE_RESOURCE_DATA_ENTRY结构体解析</span></span><br><span class="line">        &#125; DUMMYSTRUCTNAME2;</span><br><span class="line">    &#125; DUMMYUNIONNAME2;</span><br><span class="line">&#125; IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二个union是用来判断是文件还是文件夹，也是看最高位，如果最高位为1，则为文件夹，那么偏移的地址的结构就是_IMAGE_RESOURCE_DIRECTORY。如果最高位为0，则是一个文件，那么按照_IMAGE_RESOURCE_DATA_ENTRY结构进行解析</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当进行到第三层，是一个代码页</span></span><br></pre></td></tr></table></figure>

<p>这个结构体总共是两个DWORD的大小，第一个DWORD最高位不为1，则该DWORD就是代表ID值，否则就是代表字符串的偏移</p>
<p>我们可以看到，图片里共有七个这样的结构，他们的ID分别是3 4 5 6 9 E 0x18，这个其实是资源的种类，可以用VS查看下</p>
<p><img src="/PE/1714274254650.png" alt="1714274254650"></p>
<p>随便拿一个ID为3的，即RT_ICON<br>_IMAGE_RESOURCE_DIRECTORY_ENTRY结构中解析出ID号为3，最高位为1，是一个文件夹，要按照 _IMAGE_RESOURCE_DIRECTORY进行解析</p>
<p>解析到RT_MENU的结果（unicode编码）</p>
<p><img src="/PE/1714276000712.png" alt="1714276000712"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Ccai</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/PE/">http://example.com/PE/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Cc12138's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/PE/">PE</a></div><div class="post_share"><div class="social-share" data-image="/img/WangFei2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/Loader%E7%9A%84%E7%BC%96%E5%86%99/" title="免杀——Loader编写"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">免杀——Loader编写</div></div></a></div><div class="next-post pull-right"><a href="/%E6%97%A0%E6%A8%A1%E5%9D%97%E6%B3%A8%E5%85%A5%E5%99%A8/" title="无模块注入Dll器项目(安全启动线程版)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">无模块注入Dll器项目(安全启动线程版)</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/WangFei2.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Ccai</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">72</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">30</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/0xcc12138" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">ROIS Team Member</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%A8010Editor%E8%A7%A3%E6%9E%90PE%E5%A4%B4"><span class="toc-number">1.</span> <span class="toc-text">用010Editor解析PE头</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PE%E5%A4%B4"><span class="toc-number">2.</span> <span class="toc-text">PE头</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-DOS%E9%83%A8%E5%88%86"><span class="toc-number">2.1.</span> <span class="toc-text">1.DOS部分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-NT%E5%A4%B4"><span class="toc-number">2.2.</span> <span class="toc-text">2.NT头</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%A4%B4%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">2.2.1.</span> <span class="toc-text">文件头结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E9%A1%B9%E5%A4%B4%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">2.2.2.</span> <span class="toc-text">选项头结构体</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%8A%82%E8%A1%A8"><span class="toc-number">2.3.</span> <span class="toc-text">3.节表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Dump"><span class="toc-number">3.</span> <span class="toc-text">Dump:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%8A%82%E8%A1%A8%E6%B3%A8%E5%85%A5"><span class="toc-number">4.</span> <span class="toc-text">节表注入</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E%E8%8A%82%EF%BC%9A"><span class="toc-number">4.1.</span> <span class="toc-text">新增节：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E8%8A%82%EF%BC%9A"><span class="toc-number">4.2.</span> <span class="toc-text">扩展最后一个节：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E8%A1%A8%EF%BC%9A"><span class="toc-number">5.</span> <span class="toc-text">导入表：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A%E5%AF%BC%E5%85%A5%E8%A1%A8%EF%BC%9A"><span class="toc-number">6.</span> <span class="toc-text">绑定导入表：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E8%A1%A8%E6%B3%A8%E5%85%A5"><span class="toc-number">7.</span> <span class="toc-text">导入表注入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LoadPE"><span class="toc-number">8.</span> <span class="toc-text">LoadPE</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%BC%E5%87%BA%E8%A1%A8%EF%BC%9A"><span class="toc-number">9.</span> <span class="toc-text">导出表：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9FGetProcAddress"><span class="toc-number">9.1.</span> <span class="toc-text">模拟GetProcAddress</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E5%87%BA%E8%A1%A8%E5%BA%94%E7%94%A8"><span class="toc-number">9.2.</span> <span class="toc-text">导出表应用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8"><span class="toc-number">10.</span> <span class="toc-text">重定位表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="toc-number">10.1.</span> <span class="toc-text">重定位表结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TLS%E8%A1%A8"><span class="toc-number">11.</span> <span class="toc-text">TLS表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E5%BC%8FTLS%EF%BC%9A"><span class="toc-number">11.1.</span> <span class="toc-text">显式TLS：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%90%E5%BC%8FTLS%EF%BC%9A"><span class="toc-number">11.2.</span> <span class="toc-text">隐式TLS：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TLS-Callback-TLS%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">11.3.</span> <span class="toc-text">TLS_Callback TLS回调函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E8%A1%A8%EF%BC%9A"><span class="toc-number">12.</span> <span class="toc-text">资源表：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E8%B5%84%E6%BA%90%E8%A1%A8"><span class="toc-number">12.1.</span> <span class="toc-text">解析资源表</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/%E6%8F%90%E5%8D%87%E8%BF%9B%E7%A8%8B%E8%87%B3PPL%E6%9D%83%E9%99%90/" title="将进程提升至PPL权限">将进程提升至PPL权限</a><time datetime="2025-02-05T07:44:00.000Z" title="发表于 2025-02-05 15:44:00">2025-02-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/WDF%E5%AD%A6%E4%B9%A0/" title="WDF框架学习">WDF框架学习</a><time datetime="2025-01-12T15:00:00.000Z" title="发表于 2025-01-12 23:00:00">2025-01-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/NDIS,WFP%E7%BD%91%E7%BB%9C%E8%BF%87%E6%BB%A4/" title="NDIS/WFP网络过滤">NDIS/WFP网络过滤</a><time datetime="2025-01-12T02:32:00.000Z" title="发表于 2025-01-12 10:32:00">2025-01-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/" title="病毒分析">病毒分析</a><time datetime="2025-01-06T14:11:00.000Z" title="发表于 2025-01-06 22:11:00">2025-01-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/%E7%BD%91%E7%BB%9C%E9%98%B2%E7%81%AB%E5%A2%99%E6%8A%80%E6%9C%AFTDI/" title="TDI网络防火墙技术">TDI网络防火墙技术</a><time datetime="2025-01-06T03:28:00.000Z" title="发表于 2025-01-06 11:28:00">2025-01-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Ccai</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>