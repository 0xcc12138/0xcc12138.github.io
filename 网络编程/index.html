<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>网络编程 | Cc12138's blog</title><meta name="author" content="Ccai"><meta name="copyright" content="Ccai"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="网络编程Visual Studio跨平台因为我是一个Windows选手，VS用惯了，叫我去用别的IDE确实比吃了xx还难受，所以研究了一下如何在Windows桌面端用Visual Studio编译，运行，调试，附加调试Linux的程序 首先要按照 Visual Studio IDE跨平台编写和调试Linux C&#x2F;C++程序_visual studio跨平台编译-CSDN博客 这篇博客的内">
<meta property="og:type" content="article">
<meta property="og:title" content="网络编程">
<meta property="og:url" content="http://example.com/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="Cc12138&#39;s blog">
<meta property="og:description" content="网络编程Visual Studio跨平台因为我是一个Windows选手，VS用惯了，叫我去用别的IDE确实比吃了xx还难受，所以研究了一下如何在Windows桌面端用Visual Studio编译，运行，调试，附加调试Linux的程序 首先要按照 Visual Studio IDE跨平台编写和调试Linux C&#x2F;C++程序_visual studio跨平台编译-CSDN博客 这篇博客的内">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/WangFei2.jpg">
<meta property="article:published_time" content="2024-11-23T03:56:00.000Z">
<meta property="article:modified_time" content="2024-12-15T12:52:45.835Z">
<meta property="article:author" content="Ccai">
<meta property="article:tag" content="网络编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/WangFei2.jpg"><link rel="shortcut icon" href="/img/rose.png"><link rel="canonical" href="http://example.com/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '网络编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-12-15 20:52:45'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/WangFei2.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">73</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">30</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Cc12138's blog"><span class="site-name">Cc12138's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">网络编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-23T03:56:00.000Z" title="发表于 2024-11-23 11:56:00">2024-11-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-15T12:52:45.835Z" title="更新于 2024-12-15 20:52:45">2024-12-15</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="网络编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h1 id="Visual-Studio跨平台"><a href="#Visual-Studio跨平台" class="headerlink" title="Visual Studio跨平台"></a>Visual Studio跨平台</h1><p>因为我是一个Windows选手，VS用惯了，叫我去用别的IDE确实比吃了xx还难受，所以研究了一下如何在Windows桌面端用Visual Studio编译，运行，调试，附加调试Linux的程序</p>
<p>首先要按照 <a target="_blank" rel="noopener" href="https://blog.csdn.net/xue_nuo/article/details/106097060">Visual Studio IDE跨平台编写和调试Linux C&#x2F;C++程序_visual studio跨平台编译-CSDN博客</a> 这篇博客的内容，用ssh协议，让虚拟机和Visual Studio建立连接</p>
<p>其次，会遇到一个问题，Visual Studio大规模遇到不认识的库，疯狂报错，飘红，但是可以编译成功，这是因为VS还没把库全部拷贝过来，具体要在这里设置，点击更新或者下载即可</p>
<p><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1732873648427.png" alt="1732873648427"></p>
<p>还有，记得要以root帐户登录，这样才有足够的权限附加调试</p>
<p>但是ubuntu默认不能以root帐户登录，具体看这一篇文章 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/679473965">Ubuntu 系统直接使用 root 用户登录实例 - 知乎</a> </p>
<p>然后就可以快乐地附加调试了</p>
<p><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1732873778299.png" alt="1732873778299"></p>
<h1 id="Linux前置知识"><a href="#Linux前置知识" class="headerlink" title="Linux前置知识"></a>Linux前置知识</h1><p><strong>主要是为了网络编程的考试</strong></p>
<p>因为我是一个Windows选手，所以Linux的恶补了下</p>
<h2 id="Linux下的编译和链接"><a href="#Linux下的编译和链接" class="headerlink" title="Linux下的编译和链接"></a>Linux下的编译和链接</h2><h3 id="Linux下的动态链接"><a href="#Linux下的动态链接" class="headerlink" title="Linux下的动态链接"></a>Linux下的动态链接</h3><p>在Linux系统中，<code>ldd</code> 命令用于显示一个可执行文件或共享库所依赖的动态链接库信息。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aichch@sword-shield:~/桌面$ ldd chall </span><br><span class="line">	linux-vdso.so.1 (0x00007ffe64ded000)</span><br><span class="line">	libc.so.6 =&gt; ./libc.so.6 (0x00007fb193153000)</span><br><span class="line">	./ld-linux-x86-64.so.2 =&gt; /lib64/ld-linux-x86-64.so.2 (0x00007fb193383000)</span><br></pre></td></tr></table></figure>

<p>在Linux中，<code>linux-vdso.so.1</code>、<code>libc.so.6</code> 和 <code>ld-linux-x86-64.so.2</code> 类似于 Windows 的一些系统级 DLL 和运行时库。 </p>
<ul>
<li><code>linux-vdso.so.1</code> 是 Linux 虚拟动态共享对象 (VDSO)，它帮助用户态程序快速访问某些内核功能，而无需通过系统调用进入内核模式。常见功能包括获取时间（如 <code>gettimeofday</code>）等。 类似于 Windows 内核中的一些优化机制，比如 <code>ntdll.dll</code> 中提供的快速路径函数（如直接与内核交互的函数）。 </li>
<li><code>libc.so.6</code> 是 GNU C 库（glibc）的共享库，提供标准 C 函数（如 <code>printf</code>、<code>malloc</code>、<code>memcpy</code> 等）。它是绝大多数 Linux 应用程序的基础运行时库。  类似于 Windows 的 C 运行时库（CRT），如 <code>msvcrt.dll</code> 或更现代的 <code>ucrtbase.dll</code>，它们提供标准的 C 函数。 </li>
<li><code>ld-linux-x86-64.so.2</code>  是动态链接器（dynamic linker），负责加载和解析程序运行时所需的共享库，并启动程序。  类似于 Windows 的动态链接加载机制，尤其是 <code>LoadLibrary</code> 和 <code>GetProcAddress</code> 相关功能，动态链接器还可以类比为 Windows 中处理 PE 文件动态加载的功能模块。</li>
</ul>
<h3 id="GCC的编译常见选项"><a href="#GCC的编译常见选项" class="headerlink" title="GCC的编译常见选项"></a>GCC的编译常见选项</h3><p>基本编译选项 </p>
<p><code>-c</code>：仅编译，不进行链接，生成目标文件（<code>.o</code>）。</p>
<p><code>-o </code>：指定输出文件名。</p>
<p><code>-E</code>：仅进行预处理，不进行编译。</p>
<p><code>-S</code>：将代码编译成汇编代码，而不是目标文件。</p>
<p><code>-v</code>：显示详细的编译过程。</p>
<p><code>--help</code>：显示可用选项的帮助信息</p>
<p><strong>优化选项</strong> </p>
<p><code>-O0</code>：关闭优化（默认）。</p>
<p><code>-O1</code>：基本优化，编译速度快。</p>
<p><code>-O2</code>：进一步优化，包括更多代码改进。</p>
<p><code>-O3</code>：最高级别优化，启用 CPU 密集型优化（如循环展开）。</p>
<p><code>-Os</code>：优化生成的代码大小。</p>
<p><code>-Ofast</code>：极致优化，不考虑标准兼容性。</p>
<p><code>-funroll-loops</code>：展开循环，可能提高性能。</p>
<p><strong>调试相关选项</strong> </p>
<p> <code>-g</code>：生成调试信息，用于调试工具（如 <code>gdb</code>） </p>
<p>调试的时候，不要开优化</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcc -c test.c -g -O0 -o test.o</span><br><span class="line">gcc test.o -o <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">gcc test.c -g -O0 -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure>





<p><strong>标准和架构支持</strong> </p>
<p><code>-std=&lt;standard&gt;</code>：指定使用的 C 或 C++ 标准，如：<br><code>-std=c89</code>、<code>-std=c99</code>、<code>-std=c11</code>（C 标准）。<br><code>-std=c++98</code>、<code>-std=c++11</code>、<code>-std=c++17</code>（C++ 标准）。</p>
<p><code>-m32</code>：生成 32 位代码。</p>
<p><code>-m64</code>：生成 64 位代码</p>
<h3 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h3><p><code>Makefile</code> 文件描述了 <code>Linux</code> 系统下 <code>C/C++</code> 工程的编译规则，它用来自动化编译 <code>C/C++</code> 项目。一旦写编写好 <code>Makefile</code> 文件，只需要一个 <code>make</code> 命令，整个工程就开始自动编译，不再需要手动执行 <code>GCC</code> 命令。 </p>
<p>具体参考这篇文章吧，用到了再用AI生成<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/wohu1104/article/details/110905996">浅显易懂 Makefile 入门 （01）— 什么是Makefile、为什么要用Makefile、Makefile规则、Makefile流程如何实现增量编译_makefile是干什么的-CSDN博客</a> </p>
<h2 id="和Windows的一些类比"><a href="#和Windows的一些类比" class="headerlink" title="和Windows的一些类比"></a>和Windows的一些类比</h2><p>鉴于本人技能树全点Windows了，看到Linux的一些专业术语真的是懵的一批，下面介绍下我认为的类比</p>
<h3 id="Linux的文件描述符："><a href="#Linux的文件描述符：" class="headerlink" title="Linux的文件描述符："></a><strong>Linux的文件描述符：</strong></h3><p>是Linux操作系统内核用来标识和管理文件资源的整型标识符。它是一个非负整数，用于指代被打开的文件，所有执行I&#x2F;O操作的系统调用都通过文件描述符来实现。文件描述符不仅用于文件，还可以表示其他资源，如套接字、管道等。<br>在Windows操作系统中，与Linux的文件描述符相似的概念是文件句柄（File Handle）。Windows文件句柄是Windows操作系统用于表示文件资源的抽象，每一个文件、设备、管道等系统资源在打开后会获得一个唯一的句柄，作为进程访问该资源的标识。句柄本质上是对对象的指针 </p>
<h3 id="一些函数"><a href="#一些函数" class="headerlink" title="一些函数"></a>一些函数</h3><p><strong><code>fork</code>和<code>exec</code></strong></p>
<p><code>fork</code> 是一个系统调用，用于创建一个新的进程。<strong>新进程（子进程）</strong> 是 <strong>父进程</strong> 的副本，包括代码段、数据段、文件描述符等，但两者运行在独立的内存空间中。</p>
<p>子进程从 <code>fork</code></p>
<ul>
<li>父进程中，<code>fork</code> 返回子进程的 PID。</li>
<li>子进程中，<code>fork</code> 返回 0。</li>
</ul>
<p><code>exec</code> 是一组系统调用，用于替换当前进程的内存空间并执行新的程序。 </p>
<p>调用 <code>exec</code> 后，当前进程的代码、数据段被新程序替换，但 PID 不变。</p>
<p>适合用于加载新的二进制文件，配合 <code>fork</code> 实现父子进程的分工。</p>
<p>实现类似Windows的<code>CreateProcess</code>的代码<br><code>a</code> 程序调用 <code>fork</code> 创建子进程，然后在子进程中用 <code>exec</code> 加载并运行 <code>b</code> 程序 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();  <span class="comment">// 创建子进程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fork failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程：加载 b 程序</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child process: Starting program b\n&quot;</span>);</span><br><span class="line">        <span class="built_in">execl</span>(<span class="string">&quot;/path/to/b&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="literal">NULL</span>);  <span class="comment">// 替换为 b 的路径</span></span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;execl failed&quot;</span>);  <span class="comment">// 如果execl失败，打印错误</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程：等待子进程完成</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent process: Waiting for child process\n&quot;</span>);</span><br><span class="line">        <span class="type">int</span> status;</span><br><span class="line">        <span class="built_in">waitpid</span>(pid, &amp;status, <span class="number">0</span>);  <span class="comment">// 等待子进程结束</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Child process exited with status %d\n&quot;</span>, <span class="built_in">WEXITSTATUS</span>(status));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><code>wait</code>函数：</p>
<p><code>wait</code> 函数用于使父进程暂停执行，直到一个或多个子进程结束。这个函数通常与 <code>fork</code> 函数一起使用，以确保父进程在继续执行之前等待其子进程完成它们的任务。<code>wait</code> 函数可以获取子进程的终止状态，这对于获取子进程的退出代码或了解子进程是否因为信号而终止非常有用。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid1 = fork(); <span class="comment">// 创建第一个子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid2 = fork(); <span class="comment">// 创建第二个子进程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid1 == <span class="number">0</span> || pid2 == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is a child process.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>); <span class="comment">// 子进程休眠2秒</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 子进程结束</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="type">int</span> status;</span><br><span class="line">        <span class="type">pid_t</span> wpid;</span><br><span class="line"></span><br><span class="line">        wpid = <span class="built_in">waitpid</span>(pid1, &amp;status, <span class="number">0</span>); <span class="comment">// 等待第一个子进程结束</span></span><br><span class="line">        <span class="keyword">if</span> (wpid == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;First child process with PID %d has finished.\n&quot;</span>, wpid);</span><br><span class="line"></span><br><span class="line">        wpid = <span class="built_in">waitpid</span>(pid2, &amp;status, <span class="number">0</span>); <span class="comment">// 等待第二个子进程结束</span></span><br><span class="line">        <span class="keyword">if</span> (wpid == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Second child process with PID %d has finished.\n&quot;</span>, wpid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>在Windows与之对应的是<code>WaitForSingleObject</code>和<code>WaitForMultipleObjects</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建多个子进程</span></span><br><span class="line">    STARTUPINFO si1 = &#123; <span class="number">0</span> &#125;, si2 = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PROCESS_INFORMATION pi1 = &#123; <span class="number">0</span> &#125;, pi2 = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    si1.cb = <span class="built_in">sizeof</span>(si1);</span><br><span class="line">    si2.cb = <span class="built_in">sizeof</span>(si2);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* processName1 = <span class="string">&quot;notepad.exe&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* processName2 = <span class="string">&quot;calc.exe&quot;</span>; <span class="comment">// 启动计算器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建第一个子进程</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">CreateProcess</span>(</span><br><span class="line">            <span class="literal">NULL</span>, (LPSTR)processName1, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si1, &amp;pi1)) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to create first process. Error code: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建第二个子进程</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">CreateProcess</span>(</span><br><span class="line">            <span class="literal">NULL</span>, (LPSTR)processName2, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si2, &amp;pi2)) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to create second process. Error code: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Processes created. Waiting for both to finish...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进程句柄数组</span></span><br><span class="line">    HANDLE handles[<span class="number">2</span>] = &#123; pi1.hProcess, pi2.hProcess &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待多个进程结束</span></span><br><span class="line">    DWORD waitResult = <span class="built_in">WaitForMultipleObjects</span>(<span class="number">2</span>, handles, TRUE, INFINITE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (waitResult &gt;= WAIT_OBJECT_0 &amp;&amp; waitResult &lt; WAIT_OBJECT_0 + <span class="number">2</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Both processes finished.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取每个子进程的退出码</span></span><br><span class="line">        DWORD exitCode1 = <span class="number">0</span>, exitCode2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">GetExitCodeProcess</span>(pi1.hProcess, &amp;exitCode1)) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;First process exit code: &quot;</span> &lt;&lt; exitCode1 &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Failed to get first process exit code. Error code: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">GetExitCodeProcess</span>(pi2.hProcess, &amp;exitCode2)) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Second process exit code: &quot;</span> &lt;&lt; exitCode2 &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Failed to get second process exit code. Error code: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to wait for processes. Error code: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭进程和线程句柄</span></span><br><span class="line">    <span class="built_in">CloseHandle</span>(pi1.hProcess);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(pi1.hThread);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(pi2.hProcess);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(pi2.hThread);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="Linux-信号（Signal）"><a href="#Linux-信号（Signal）" class="headerlink" title="Linux 信号（Signal）"></a>Linux 信号（Signal）</h2><p>信号是一个轻量级的机制，它允许进程通过发送一个信号来通知另一个进程发生了某些事件。每个信号都与特定的事件相关联，例如：</p>
<ul>
<li><strong>SIGINT</strong>：终端中断（通常是 Ctrl+C）。</li>
<li><strong>SIGTERM</strong>：请求终止进程。</li>
<li><strong>SIGKILL</strong>：强制终止进程。</li>
<li><strong>SIGSEGV</strong>：段错误（访问无效内存）。</li>
<li><strong>SIGCHLD</strong>：子进程状态变化（如子进程退出）。</li>
</ul>
<p><strong>信号的类型</strong></p>
<ol>
<li><strong>标准信号</strong>：例如 <code>SIGKILL</code>、<code>SIGTERM</code>、<code>SIGINT</code> 等，它们用于通知进程发生的事件。</li>
<li><strong>自定义信号</strong>：应用程序可以使用 <code>SIGUSR1</code> 和 <code>SIGUSR2</code> 作为用户定义的信号来执行某些自定义行为。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signal_handler</span><span class="params">(<span class="type">int</span> signal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (signal == SIGINT) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Caught SIGINT, exiting program...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, signal_handler); <span class="comment">// 注册 SIGINT 信号处理程序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 程序继续运行，等待信号</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Running... Press Ctrl+C to send SIGINT\n&quot;</span>);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Windows 中的类似机制是 <strong>事件</strong> 和 <strong>异常处理</strong>。 </p>
<h2 id="Linux下的同步机制"><a href="#Linux下的同步机制" class="headerlink" title="Linux下的同步机制"></a>Linux下的同步机制</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1  <span class="comment">// 缓冲区大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓冲区和互斥锁</span></span><br><span class="line"><span class="type">int</span> buffer = <span class="number">0</span>;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">producer</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 模拟生产数据</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);  <span class="comment">// 生产过程等待一秒</span></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);  <span class="comment">// 获取互斥锁</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果缓冲区已满，等待消费者消费数据</span></span><br><span class="line">        <span class="keyword">while</span> (buffer == BUFFER_SIZE) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Producer: Buffer is full, waiting for consumer...\n&quot;</span>);</span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;cond, &amp;mutex);  <span class="comment">// 等待消费者唤醒</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产数据</span></span><br><span class="line">        buffer = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Producer: Produced data, buffer = %d\n&quot;</span>, buffer);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知消费者可以消费数据了</span></span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;cond);  <span class="comment">// 唤醒消费者</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);  <span class="comment">// 释放互斥锁</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">consumer</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 模拟消费数据</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);  <span class="comment">// 消费过程等待两秒</span></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);  <span class="comment">// 获取互斥锁</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果缓冲区为空，等待生产者生产数据</span></span><br><span class="line">        <span class="keyword">while</span> (buffer == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Consumer: Buffer is empty, waiting for producer...\n&quot;</span>);</span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;cond, &amp;mutex);  <span class="comment">// 等待生产者唤醒</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费数据</span></span><br><span class="line">        buffer = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Consumer: Consumed data, buffer = %d\n&quot;</span>, buffer);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知生产者可以继续生产数据了</span></span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;cond);  <span class="comment">// 唤醒生产者</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);  <span class="comment">// 释放互斥锁</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> producer_thread, consumer_thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化互斥锁和条件变量</span></span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_cond_init</span>(&amp;cond, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建生产者和消费者线程</span></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;producer_thread, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;consumer_thread, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="built_in">pthread_join</span>(producer_thread, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(consumer_thread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁互斥锁和条件变量</span></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">    <span class="built_in">pthread_cond_destroy</span>(&amp;cond);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行流程：</p>
<p><strong>生产者线程执行（<code>producer</code> 函数）</strong></p>
<ul>
<li><strong>进入循环</strong>：生产者线程不断地执行生产过程。</li>
<li><strong>模拟生产</strong>：每次生产数据前，调用<code>sleep(1)</code>模拟生产需要的时间，暂停1秒。</li>
<li><strong>获取互斥锁</strong>：使用<code>pthread_mutex_lock(&amp;mutex)</code>获取互斥锁，确保缓冲区的访问是安全的。</li>
<li>缓冲区已满：如果缓冲区已满（buffer &#x3D;&#x3D; BUFFER_SIZE），生产者线程会进入while循环，调用<code>pthread_cond_wait(&amp;cond, &amp;mutex)</code>等待消费者消费数据。<ul>
<li>在<code>pthread_cond_wait</code>时，生产者线程会自动释放<code>mutex</code>锁，并阻塞，直到消费者线程调用<code>pthread_cond_signal</code>来唤醒生产者。</li>
</ul>
</li>
<li><strong>生产数据</strong>：生产者将<code>buffer</code>设为1，表示缓冲区有数据可以消费。</li>
<li><strong>通知消费者</strong>：生产者通过调用<code>pthread_cond_signal(&amp;cond)</code>来唤醒消费者线程，通知消费者有数据可以消费了。</li>
<li><strong>释放互斥锁</strong>：生产者线程通过<code>pthread_mutex_unlock(&amp;mutex)</code>释放互斥锁，允许其他线程访问缓冲区。</li>
</ul>
<p><strong>消费者线程执行（<code>consumer</code> 函数）</strong></p>
<ul>
<li><strong>进入循环</strong>：消费者线程不断地执行消费过程。</li>
<li><strong>模拟消费</strong>：每次消费数据前，调用<code>sleep(2)</code>模拟消费过程中的等待时间，暂停2秒。</li>
<li><strong>获取互斥锁</strong>：使用<code>pthread_mutex_lock(&amp;mutex)</code>获取互斥锁，确保缓冲区的访问是互斥的。</li>
<li>缓冲区为空：如果缓冲区为空（buffer &#x3D;&#x3D; 0），消费者线程会进入while循环，调用<code>pthread_cond_wait(&amp;cond, &amp;mutex)</code>等待生产者生产数据。<ul>
<li>在<code>pthread_cond_wait</code>时，消费者线程会自动释放<code>mutex</code>锁，并阻塞，直到生产者线程通过调用<code>pthread_cond_signal</code>唤醒消费者。</li>
</ul>
</li>
<li><strong>消费数据</strong>：消费者将<code>buffer</code>设为0，表示缓冲区已经被消费。</li>
<li><strong>通知生产者</strong>：消费者通过调用<code>pthread_cond_signal(&amp;cond)</code>来唤醒生产者线程，通知生产者可以继续生产数据了。</li>
<li><strong>释放互斥锁</strong>：消费者线程通过<code>pthread_mutex_unlock(&amp;mutex)</code>释放互斥锁，允许其他线程访问缓冲区。</li>
</ul>
<p>注意， 当条件变量收到信号 <code>pthread_cond_signal</code> 会先重新尝试获取互斥锁。也就是说，当条件满足后，线程会再次尝试获得互斥锁，并在成功获得锁后才会继续执行后续的代码。 </p>
<h1 id="网络前置知识："><a href="#网络前置知识：" class="headerlink" title="网络前置知识："></a>网络前置知识：</h1><h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><p><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1732322341982.png" alt="1732322341982"></p>
<p>物理层理解为网卡驱动，链路层是让数据在局域网传播，网络层让数据满世界传输，传输层理解为决定是打电话还是发短信这样的，会话层类似于QQ的在线与否，表示层类似于中文还是英文，应用层表示是类似网页还是视频…</p>
<p>物理层：是指实际传输数据的硬件和信号机制，例如电缆、光纤、无线信号、连接器等。 </p>
<p>链路层：它负责节点之间（直接相连的设备）数据帧的可靠传输。它解决了物理层可能出现的错误，比如比特翻转，并通过 MAC 地址（硬件地址）来定位同一链路上的设备。 </p>
<p>网络层： 网络层通过 IP 地址实现设备的全局定位，确保数据包能够跨越多个子网传输到目标设备。可以理解为从发件人地址到收件人地址，确保快递包裹送达。最常见的协议是 IP（如 IPv4 和 IPv6）。  </p>
<p>传输层：  决定是打电话还是发短信，<strong>TCP</strong>：类似“打电话”，需要确认接收方在场、内容完整，建立可靠连接。  <strong>UDP</strong>：类似“发短信”，无需确认对方是否收到，快速但不可靠。 </p>
<p>应用层 ：应用层直接面向用户，为用户提供各种服务，比如 HTTP（网页）、FTP（文件传输）、SMTP（邮件）等。它相当于决定了数据的“用处”，比如浏览网页、看视频或发邮件。 </p>
<p><strong>具体来说，如果要把数据通过互联网传递到另一台主机，五层模型分别做了什么？</strong> </p>
<p>应用层：  你在浏览器中输入 URL 并按下回车键，应用层负责生成 HTTP 请求报文（比如 <code>GET /index.html HTTP/1.1</code>）。 </p>
<p>传输层：  如果你使用 HTTP 协议，传输层可能选择 TCP 协议，负责为数据添加目标端口号（如 80）和序列号。 </p>
<p>网络层 ： 网络层为数据包添加了你的主机 IP 地址（如 192.168.1.100）和目标主机 IP 地址（如 8.8.8.8）。 </p>
<p>数据链路层：  数据链路层将你的网卡的 MAC 地址（如 <code>00:11:22:33:44:55</code>）和默认网关的 MAC 地址添加到帧中。 </p>
<p>物理层 ： 数据通过网线以电信号的形式发送到路由器或交换机。 </p>
<h3 id="Ipv4和Mac地址："><a href="#Ipv4和Mac地址：" class="headerlink" title="Ipv4和Mac地址："></a><strong>Ipv4和Mac地址：</strong></h3><table>
<thead>
<tr>
<th>特性</th>
<th>IPv4地址</th>
<th>MAC地址</th>
</tr>
</thead>
<tbody><tr>
<td>协议层</td>
<td>网络层</td>
<td>数据链路层</td>
</tr>
<tr>
<td>作用</td>
<td>标识网络中的设备，主要用于路由</td>
<td>标识局域网中网络接口的硬件地址</td>
</tr>
<tr>
<td>范围</td>
<td>可以跨越多个网络（全局可见）</td>
<td>仅在同一个局域网（本地可见）使用</td>
</tr>
<tr>
<td>可变性</td>
<td>动态分配（通过DHCP或者手动设置）</td>
<td>静态（网卡烧录，可以伪造）</td>
</tr>
</tbody></table>
<p><strong>为什么局域网通信需要 MAC 地址 ?</strong></p>
<p>局域网中设备通信通常是通过 以太网协议（Ethernet） 实现的，而以太网协议运行在 数据链路层。数据链路层的核心是通过 MAC 地址 标识设备。 </p>
<p>以太网相对底层，而Ipv4是动态的，MAC是静态的，所以用MAC地址进行局域网通讯没问题，IPV4主要是设备间通讯的</p>
<h3 id="以太网："><a href="#以太网：" class="headerlink" title="以太网："></a><strong>以太网：</strong></h3><p>是一种使用有线连接的局域网（LAN）通信技术 ， 以太网通过物理线缆将设备连接到网络交换机或路由器，提供稳定和高带宽的网络通信。 </p>
<p><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1732324018609.png" alt="1732324018609"></p>
<p>以太网帧（Ethernet Frame）是局域网（LAN）中数据传输的基本单元，遵循以太网协议，通常按照IEEE 802.3标准进行封装。 </p>
<ol>
<li><strong>帧头（Header）</strong>：<ul>
<li><strong>目的地址（Destination Address）</strong>：6字节，表示数据帧的接收方MAC地址。</li>
<li><strong>源地址（Source Address）</strong>：6字节，表示数据帧的发送方MAC地址。</li>
<li><strong>类型（Type）</strong>：2字节，表示上层协议类型，如0x0800表示IP协议。</li>
</ul>
</li>
<li><strong>数据负载（Payload）</strong>：<ul>
<li>这是实际传输的数据部分，长度可以是46到1500字节。如果数据部分小于46字节，通常会用填充（padding）来补足到46字节。</li>
</ul>
</li>
<li><strong>帧校验序列（Frame Check Sequence, FCS）</strong>：<ul>
<li>4字节，用于错误检测。在发送端计算整个帧（包括帧头和数据负载）的CRC（循环冗余校验）值，并附加在帧的末尾。接收端会重新计算接收到的帧的CRC值，并与接收到的FCS进行比较，以验证数据的完整性。</li>
</ul>
</li>
</ol>
<h3 id="ARP地址解析协议"><a href="#ARP地址解析协议" class="headerlink" title="ARP地址解析协议"></a>ARP地址解析协议</h3><p>ARP（Address Resolution Protocol，地址解析协议）是一种网络层协议，用于将网络层的IP地址解析为数据链路层的MAC地址。 通俗来说，就是为了不同机器之间找目标机器的网卡MAC地址进行通讯</p>
<p>具体可以在WireShark进行抓包，发现会向全部端口发送信号，询问某个IPv4地址属于来自哪个网卡，只要有回应，就会做成一张表，记录对应的IP和MAC地址</p>
<p><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1732326751103.png" alt="1732326751103"></p>
<h3 id="子网，子网掩码，网关"><a href="#子网，子网掩码，网关" class="headerlink" title="子网，子网掩码，网关"></a>子网，子网掩码，网关</h3><p>子网（Subnetwork）是网络的一个子集，它由一个较大的网络划分而成，通常用于提高网络性能、增强安全性、优化广播域和路由效率。  通过创建子网，可以限制广播流量只在子网内部传播，而不是在整个大网络中，这有助于减少网络拥塞和提高效率。 </p>
<p>子网掩码是例如<code>255.255.255.0</code>这样的，将它和任意IP地址异或，可以获得子网的基地址</p>
<p><strong>网关的作用：</strong></p>
<ol>
<li><strong>局域网内通信</strong>：同一子网内的设备可以直接通信，无需经过网关。</li>
<li><strong>跨子网通信</strong>：当两个设备属于不同子网时，需要通过网关进行数据的转发。</li>
<li><strong>访问外网</strong>：当设备需要与互联网通信时，数据会发送到网关，由网关转发到外部网络。</li>
</ol>
<p><strong>跨子网通信（需要网关）</strong></p>
<ul>
<li><strong>场景</strong>：设备 A（<code>192.168.1.10</code>）想与设备 C（<code>192.168.2.10</code>）通信，它们在不同子网：<ul>
<li>A 的子网：<code>192.168.1.0/24</code>。</li>
<li>C 的子网：<code>192.168.2.0/24</code>。</li>
<li>网关地址：<code>192.168.1.1</code>（A 的默认网关）。</li>
</ul>
</li>
<li><strong>过程</strong>：<ol>
<li>A 检查目标地址 C 是否在同一子网：<ul>
<li>A 的网络部分：<code>192.168.1</code>。</li>
<li>C 的网络部分：<code>192.168.2</code>。</li>
<li>结果：不在同一子网。</li>
</ul>
</li>
<li>A 将数据包发送到网关（192.168.1.1）：<ul>
<li>A 通过 ARP 协议获取网关的 MAC 地址。</li>
<li>数据包的目标 MAC 地址设为网关的 MAC，目标 IP 地址保持为 C 的 IP。</li>
</ul>
</li>
<li>网关接收数据包，检查目标 IP 地址（C 的 IP），发现它不在自己的子网内。</li>
<li>网关根据路由表决定如何将数据转发到 C 所在的子网：<ul>
<li>如果网关与 C 在同一子网，直接转发。</li>
<li>如果不在，则继续向上游网关转发，直到数据到达目标子网。</li>
</ul>
</li>
<li>数据到达 C。</li>
</ol>
</li>
</ul>
<h3 id="VMWare的桥接和NAT的区别"><a href="#VMWare的桥接和NAT的区别" class="headerlink" title="VMWare的桥接和NAT的区别"></a>VMWare的桥接和NAT的区别</h3><p><strong>桥接</strong>的原理相当于是在局域网内加了一台和本机地位一样的机器，例如本机的IP地址是<code>192.168.6.90</code>，那么桥接出来的机器，IP地址可能是<code>192.168.6.88</code>，可以理解为这两个机器都平等地接在一个交换机上</p>
<p><strong>NAT</strong>的话是通过一个NAT设备进行地址转换，所以相当于本机是一个服务端（IP地址假设为<code>192.168.6.90</code>），然后接了一个NAT盒子IP地址是<code>192.168.132.1</code>，然后虚拟机<code>192.168.132.128</code>接在这个NAT盒子上。这样就是虚拟机可以访问外网，但是从外面找不到虚拟机</p>
<p><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1732327534600.png" alt="1732327534600"></p>
<p>如果路由器坏了，桥接模式之间就不能进行通讯了，但是NAT可以</p>
<h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a><strong>特点：</strong></h4><ol>
<li><strong>面向连接（有连接）</strong>：<ul>
<li>TCP是一个面向连接的协议，这意味着在数据传输开始之前，必须在通信的两个端点之间建立一个连接。这个过程称为三次握手，确保了双方都能发送和接收数据。</li>
</ul>
</li>
<li><strong>可靠</strong>：<ul>
<li>TCP通过使用序列号、确认应答（ACK）、重传机制和数据校验和来确保数据的可靠传输。如果数据包在传输过程中丢失或损坏，TCP会请求重传丢失的数据包，并重新组装数据以确保正确无误。</li>
</ul>
</li>
<li><strong>有序</strong>：<ul>
<li>TCP保证数据包按照发送的顺序到达接收端。即使在网络中数据包可能乱序到达，TCP也会在接收端对数据包进行排序，确保应用程序接收到的数据是有序的。</li>
</ul>
</li>
<li><strong>端到端</strong>：<ul>
<li>TCP提供端到端的通信，这意味着它负责在发送端和接收端之间建立和管理连接，而不需要中间网络设备（如路由器）参与数据传输的控制。</li>
</ul>
</li>
<li><strong>全双工</strong>：<ul>
<li>TCP允许数据在两个方向上同时传输，即发送方和接收方都可以同时发送和接收数据。这种全双工通信模式提高了网络的效率。</li>
</ul>
</li>
<li><strong>流量控制</strong>：<ul>
<li>TCP通过流量控制机制（如滑动窗口协议）来防止发送方发送数据过快，导致接收方来不及处理。这有助于避免网络拥塞和数据丢失。</li>
</ul>
</li>
<li><strong>拥塞控制</strong>：<ul>
<li>TCP还实现了拥塞控制算法（如慢启动、拥塞避免、快速重传和快速恢复），以适应网络条件的变化，减少网络拥塞的影响。</li>
</ul>
</li>
<li><strong>错误检测</strong>：<ul>
<li>TCP使用校验和来检测数据在传输过程中是否发生错误。如果检测到错误，TCP会请求重传损坏的数据包。</li>
</ul>
</li>
</ol>
<h4 id="四次握手-三次握手"><a href="#四次握手-三次握手" class="headerlink" title="四次握手-&gt;三次握手"></a>四次握手-&gt;三次握手</h4><p><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1732330925056.png" alt="1732330925056"></p>
<p>如上图，阿强是Client，阿珍是Server端，两个人要建立通讯，也就是C和S端都要确保管道1，2的读写端都开启</p>
<p>首先C向S发送一条“你好”的信息，这样可以C知道管道1的W端已经开放</p>
<p>然后S端收到来自C端的信息，这样S端可以知道管道1的W,R已经开启</p>
<p>接着S端向C端发送 <code>确认</code> 的信息，这样C端就知道管道1的R开好了<br>至此，双方都确认了管道1的R,W端开好了</p>
<p>接下来是S端向C端发送一个”你好”的请求，这样S端知道了管道2的W开好了</p>
<p>C端接收到了S端的信息，这样C端就知道了管道2的R,W端都开好了</p>
<p>于是C端返回一个“确认”给S端，S端接收到以后，S端就知道管道2的R开好了</p>
<p>至此，C和S都知道了管道1 2的W R都开放了，就可以开始通讯了</p>
<p>以上是四次握手</p>
<p>但是我们从网上查到的是三次握手啊？？</p>
<p><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1732332175936.png" alt="1732332175936"></p>
<p>这是因为，S端发送确认和你好，C端接收 其实应该是在同一次完成的</p>
<p>（这里要注意下建立连接不走管道），所以是三次握手</p>
<p>简化来说就是这样：</p>
<p><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1732332341555.png" alt="1732332341555"></p>
<h5 id="三次握手的状态变化："><a href="#三次握手的状态变化：" class="headerlink" title="三次握手的状态变化："></a>三次握手的状态变化：</h5><p><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1732674027360.png" alt="1732674027360"></p>
<h5 id="可靠性的实现"><a href="#可靠性的实现" class="headerlink" title="可靠性的实现"></a>可靠性的实现</h5><p>丢包重传:</p>
<p>客户端发出去一个包，服务器要回复一个ACK（表示收到），如果一定时间内没收到ACK，客户端会重新发包</p>
<p><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1732332733617.png" alt="1732332733617"></p>
<p>但是服务端没发ACK又有两种情况，一种是服务端收到消息了，但是ACK发不出去，另一种是没收到，那么这个如何解决呢？</p>
<p><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1732333137098.png" alt="1732333137098"></p>
<p>TCP引入了序号机制，让接收方区分是新包还是重传包，还解决了有序性</p>
<p>另外一个个包等待接收到才继续发效率太低了，一般都是先不管确认，直接发的，所以ACK也要带上序号信息</p>
<p><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1732333383985.png" alt="1732333383985"></p>
<p>当然不确认发信息是有风险的，所以TCP有一个已发未确认是有上限的 </p>
<p>三次握手的状态变化</p>
<p><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1732674027360.png" alt="1732674027360"></p>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p><strong>断开连接</strong>时，双方的发送数据和接收数据是<strong>完全独立的过程</strong>。一方停止发送数据，并不意味着另一方也同时完成了数据发送。因此，双方需要分别关闭发送方向： </p>
<p><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1732633261590.png" alt="1732633261590"></p>
<p>过程是这样的，如上图</p>
<p><strong>p1发送给P2一个关闭的信号</strong></p>
<p>发送时，P1知道了管道1的W关了</p>
<p>接收时，P2知道管道1的WR关了</p>
<p><strong>P2给P1发送一个收到的信息</strong></p>
<p>发送时，P2知道管道1的WR关了</p>
<p>接收时，P1知道管道1的WR关了</p>
<p>至于为什么要分开，可以这么理解，一个人不得给另一个人写点小作文😂（也就是还有数据要传输）</p>
<p>所以还有单向的数据需要传输，所以不能合并</p>
<p><strong>结束以后P2再给P1发送关闭的信息</strong></p>
<p>发送时，P2知道管道2的W关了</p>
<p>接收时，P1知道管道2的WR关了</p>
<p><strong>P1再给P2发送一个收到的信息</strong></p>
<p>发送时，P1知道管道2的WR关了</p>
<p>接收时，P2知道管道2的WR关了</p>
<p>至此，结束</p>
<p><strong>四次挥手的状态变化：</strong></p>
<p><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1732697149772.png" alt="1732697149772"></p>
<p>FIN：是断开连接的请求</p>
<h4 id="查看TCP连接"><a href="#查看TCP连接" class="headerlink" title="查看TCP连接"></a>查看TCP连接</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user@sword-shield:~$ netstat -an</span><br></pre></td></tr></table></figure>

<p><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1732672534559.png" alt="1732672534559"></p>
<p>State有以下几种状态：</p>
<p><strong>ESTABLISHED</strong> 状态表示两端之间的三次握手已经完成，连接进入可用状态，可以发送和接收数据。 </p>
<p><strong>LISTEN</strong>: 表示服务器端在等待连接请求。对方发来建立连接的请求，此时服务端必须在处于LISTEN的状态</p>
<p><strong>SYN_SENT &#x2F; SYN_RECV</strong>: 表示三次握手的中间状态。</p>
<p><strong>TIME_WAIT</strong>: 表示连接已经关闭，但系统等待确保远程端接收到最后的ACK。</p>
<p><strong>CLOSE_WAIT</strong>: 表示连接已被远端关闭，本地仍需要完成关闭操作。</p>
<h4 id="TCP协议重要字段："><a href="#TCP协议重要字段：" class="headerlink" title="TCP协议重要字段："></a>TCP协议重要字段：</h4><p><strong>URG (Urgent)</strong> </p>
<p><strong>描述</strong>: 表示当前数据段包含紧急数据。 </p>
<p><strong>作用</strong>:</p>
<p>紧急数据需要优先处理，而无需等待接收方的缓冲队列。</p>
<p><strong>紧急指针</strong>字段指示紧急数据在TCP数据段中的结束位置。</p>
<p><strong>RST (Reset) ：</strong> </p>
<p>TCP报文头中的一个标志位，用于强制终止连接。 </p>
<p>当一方收到一个无法识别的包或认为连接出错时，会发送一个带有RST标志的包通知对方立即终止连接。 </p>
<p><strong>SYN (Synchronize)</strong> </p>
<p><strong>描述</strong>: TCP报文头中的一个标志位，用于发起连接请求（同步序列号）。 </p>
<p><strong>作用</strong>: 用于三次握手中的第一步，通知对方要建立连接并同步序列号。 </p>
<p>**ACK (Acknowledgment) **</p>
<p><strong>描述</strong>: TCP报文头中的一个标志位，表示对收到数据的确认。</p>
<p><strong>作用</strong>: 用于确认接收到的数据包。每个TCP报文都会包含ACK以指明收到的最后一个字节的序列号。</p>
<p>**SEQ (Sequence Number) **</p>
<p><strong>描述</strong>: TCP报文头中的一个字段，表示数据包中的字节序列号。</p>
<p><strong>作用</strong>: 用于标记当前报文中的数据在整个数据流中的位置，保证数据的有序性和完整性。</p>
<p><strong>PSH (Push)</strong> </p>
<p><strong>描述</strong>: 提示接收方尽快将当前数据推送到上层应用。 </p>
<p>通知接收方不再等待更多数据，立即处理本段数据。</p>
<p>通常用于实时性要求较高的场景。</p>
<h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><p><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1732709590305.png" alt="1732709590305"></p>
<p><strong>TCP 和 UDP 是不同的协议，它们各自有独立的端口号空间</strong>。尽管同一台机器上使用相同的端口号（如 <code>80</code>），但 TCP 和 UDP 的服务互不干扰。 </p>
<h3 id="本机地址和本地环回地址"><a href="#本机地址和本地环回地址" class="headerlink" title="本机地址和本地环回地址"></a>本机地址和本地环回地址</h3><p><code>127.0.0.1</code> 是回环地址（loopback address），始终指向本机，且不依赖任何物理网络设备。 </p>
<p><code>192.168.xxx.xxx</code> 是本机在局域网 (LAN) 中的 IP 地址，是分配给本地网络接口的有效地址。 </p>
<p>区别是</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>127.0.0.1</th>
<th>192.168.xxx.xxx</th>
</tr>
</thead>
<tbody><tr>
<td>地址类型</td>
<td>回环地址，只能用于本机</td>
<td>局域网地址，可以与其他设备进行通讯</td>
</tr>
<tr>
<td>是否需要网络支持</td>
<td>不需要，完全本地化</td>
<td>需要，以来网络接口和配置</td>
</tr>
<tr>
<td>通信范围</td>
<td>仅限本机</td>
<td>本机和局域网其他设备</td>
</tr>
<tr>
<td>速度</td>
<td>高速，直接本地处理</td>
<td>取决于网络宽带和延迟</td>
</tr>
<tr>
<td>测试用途</td>
<td>常用于测试本地服务</td>
<td>用于验证设备间或者服务间的连接</td>
</tr>
</tbody></table>
<p> 使用 <code>192.168.xxx.xxx</code> 在本机和本机通讯时，通信数据会经过<strong>网卡</strong> 等设备，绕一圈再回到本机，相比于127.0.0.1确实慢不少</p>
<h1 id="Linux下的网络编程"><a href="#Linux下的网络编程" class="headerlink" title="Linux下的网络编程"></a>Linux下的网络编程</h1><h2 id="ip地址结构和字节序"><a href="#ip地址结构和字节序" class="headerlink" title="ip地址结构和字节序"></a>ip地址结构和字节序</h2><p>在Linux找对应结构体：</p>
<p>因为Linux是一个开源的操作系统，所有头文件都放在了&#x2F;user&#x2F;include这个文件夹，我做的是把这玩意拖出来放到windows端，然后把文件夹扔到vscode里面，这时候就可以通过符号进行查找结构体</p>
<p><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1732714480335.png" alt="1732714480335"></p>
<p>这是Ipv4的具体类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个结构体是一个专门用于存储 IPv4 地址信息的结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> &#123;</span><br><span class="line">  <span class="type">__kernel_sa_family_t</span>	sin_family;	<span class="comment">//指定地址族（address family），通常设置为 AF_INET，表示 IPv4 地址。</span></span><br><span class="line">  __be16		sin_port;	<span class="comment">//指定端口号，采用大端字节序（Big Endian）进行存储。</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">in_addr</span>	sin_addr;	<span class="comment">//存储 IPv4 地址的结构体</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/* Internet address. */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span> &#123;</span><br><span class="line">	__be32	s_addr;<span class="comment">//存储一个 32 位的 IPv4 地址。它是一个无符号整型，表示一个 IPv4 地址，采用大端字节序（Big Endian）。</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>



<p>这是IPV6的具体类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in6</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span>	sin6_family;    <span class="comment">/* AF_INET6 */</span></span><br><span class="line">	__be16			sin6_port;      <span class="comment">/* Transport layer port # */</span></span><br><span class="line">	__be32			sin6_flowinfo;  <span class="comment">/* IPv6 flow information */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">in6_addr</span>		sin6_addr;      <span class="comment">/* IPv6 address */</span></span><br><span class="line">	__u32			sin6_scope_id;  <span class="comment">/* scope id (new in RFC2553) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __UAPI_DEF_IN6_ADDR</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in6_addr</span> &#123;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		__u8		u6_addr8[<span class="number">16</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __UAPI_DEF_IN6_ADDR_ALT</span></span><br><span class="line">		__be16		u6_addr16[<span class="number">8</span>];</span><br><span class="line">		__be32		u6_addr32[<span class="number">4</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	&#125; in6_u;</span><br></pre></td></tr></table></figure>



<p>IP类型那么多，有没有办法统一？不然代码要一直重写？</p>
<p><code>struct sockaddr</code> 是一个统一的类型，它在网络编程中作为一个通用的套接字地址结构，允许在不同的地址族（如 IPv4、IPv6 等）中共享一个统一的接口。 可以看到<code>struct sockaddr</code>用的是IPV4和IPV6的公共部分</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr</span> &#123;</span><br><span class="line">  __SOCKADDR_COMMON (sa_);    <span class="comment">/* Common data: address family and length. */</span></span><br><span class="line">  <span class="type">char</span> sa_data[<span class="number">14</span>];           <span class="comment">/* Address data. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>**<code>__SOCKADDR_COMMON (sa_)</code>**： 这是一个宏，它定义了与地址族相关的共同字段。通常，这些字段包括：</p>
<ul>
<li><code>sa_family</code>：地址族，通常是 <code>AF_INET</code>（IPv4）或 <code>AF_INET6</code>（IPv6），表示地址类型。</li>
<li><code>sa_len</code>：这个字段在某些系统上（如 BSD 系列）用于表示地址结构的长度。它是为了确保传递地址时不会发生缓冲区溢出的问题。</li>
</ul>
<p>**<code>char sa_data[14];</code>**： 这是一个固定大小的字符数组，用于存储地址族特定的地址信息。具体内容取决于地址族的类型。</p>
<ul>
<li>对于 IPv4，<code>sa_data</code> 会包含 4 字节的 IP 地址和 2 字节的端口号。</li>
<li>对于 IPv6，<code>sa_data</code> 会包含 16 字节的 IP 地址和 2 字节的端口号。</li>
</ul>
<p><strong>大小端转换</strong></p>
<p>在网络设备都是大端序，在主机设备是小端序</p>
<p>大小端转换是为了保持真值不变</p>
<p>相关函数：</p>
<p><strong>htons</strong> ： Host TO Network Short。 将 <strong>16位短整型数（short）</strong> 从主机字节序转换为网络字节序。 </p>
<p><strong>ntohs</strong> ： Network TO Host Short。  将 <strong>16位短整型数（short）</strong> 从网络字节序转换为主机字节序。 </p>
<p><strong>htonl</strong> ： Host TO Network Long。  <strong>功能</strong>：将 <strong>32位长整型数（long）</strong> 从主机字节序转换为网络字节序。 </p>
<p><strong>ntohl</strong> ： Network TO Host Long。  <strong>功能</strong>：将 <strong>32位长整型数（long）</strong> 从网络字节序转换为主机字节序。 </p>
<p><strong>inet_addr</strong> ： <strong>功能</strong>：将 <strong>字符串格式的IPv4地址</strong> 转换为 <strong>网络字节序的整数值（<code>uint32_t</code>）</strong>。 </p>
<p><strong>inet_ntoa</strong> ： <strong>功能</strong>：将 <strong>网络字节序的IPv4地址</strong> 转换为 <strong>字符串格式的IPv4地址</strong>。 </p>
<p><strong>inet_ntop</strong> ： <strong>功能</strong>：将 <strong>网络字节序的二进制格式的IP地址</strong> 转换为 <strong>字符串格式</strong>。 </p>
<p><strong>inet_pton</strong>：<strong>功能</strong>：将 <strong>字符串格式</strong>转换为 <strong>网络字节序的二进制格式的IP地址</strong> 。 </p>
<h2 id="TCP编程过程"><a href="#TCP编程过程" class="headerlink" title="TCP编程过程"></a>TCP编程过程</h2><p>TCP的底层操作系统已经帮我们实现了，我们只需要在应用层做动作就行</p>
<p><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1732756605523.png" alt="1732756605523"></p>
<p>这图有点瑕疵，3和4顺序要反过来</p>
<h2 id="重要函数"><a href="#重要函数" class="headerlink" title="重要函数"></a>重要函数</h2><p><strong>getThostbyname</strong></p>
<p><code>gethostbyname</code> 函数 </p>
<p>将主机名（如域名 <code>www.google.com</code>）解析为对应的IP地址。 </p>
<p>使用DNS协议，根据域名获取IP，这个API断网不能用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hostent</span> *<span class="built_in">gethostbyname</span>(<span class="type">const</span> <span class="type">char</span> *name);</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">hostent</span> &#123;</span><br><span class="line">    <span class="type">char</span>    *h_name;         <span class="comment">// 主机的正式名称</span></span><br><span class="line">    <span class="type">char</span>    **h_aliases;     <span class="comment">// 主机的别名</span></span><br><span class="line">    <span class="type">int</span>     h_addrtype;      <span class="comment">// 地址类型（AF_INET）</span></span><br><span class="line">    <span class="type">int</span>     h_length;        <span class="comment">// 地址长度</span></span><br><span class="line">    <span class="type">char</span>    **h_addr_list;   <span class="comment">// 主机地址列表（可以有多个），这里是32bit大端，而不是字符串</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以获取一个主机名的所有域名，还有所有IP地址</p>
<p><strong>socket</strong>：套接字，理解为 IP+端口</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>

<p> **<code>domain</code> (协议族)**： 指定通信的地址族或协议族。 </p>
<p> <strong>常用选项</strong>： </p>
<ul>
<li><code>AF_INET</code>: 用于 IPv4 网络。</li>
<li><code>AF_INET6</code>: 用于 IPv6 网络。</li>
<li><code>AF_UNIX</code> (或 <code>AF_LOCAL</code>): 用于本地套接字（文件系统中的套接字文件）。</li>
<li><code>AF_PACKET</code>: 用于低级别访问网络接口（数据链路层）。</li>
</ul>
<p><strong>作用</strong>：决定套接字的地址格式和通信域。</p>
<p>**<code>type</code> (套接字类型)**： 指定套接字的类型，决定通信的特性。（传输层）</p>
<ul>
<li>常用选项：<ul>
<li><code>SOCK_STREAM</code>: 提供可靠的、面向连接的通信（如 TCP）。</li>
<li><code>SOCK_DGRAM</code>: 提供无连接的、不可靠的通信（如 UDP）。</li>
<li><code>SOCK_RAW</code>: 允许直接操作 IP 数据报（需要超级用户权限）。</li>
</ul>
</li>
</ul>
<p> <strong>作用</strong>：定义数据传输的方式。 </p>
<p>**<code>protocol</code> (协议)**： 指定具体的协议，一般设为 <code>0</code> 让系统自动选择默认协议。</p>
<ul>
<li>常用选项：<ul>
<li><code>IPPROTO_TCP</code>: TCP 协议（仅适用于 <code>SOCK_STREAM</code>）。</li>
<li><code>IPPROTO_UDP</code>: UDP 协议（仅适用于 <code>SOCK_DGRAM</code>）。</li>
<li><code>IPPROTO_ICMP</code>: ICMP 协议（常用于 <code>SOCK_RAW</code>）。</li>
</ul>
</li>
<li><strong>作用</strong>：决定传输协议。如果只有一种协议与所选的 <code>type</code> 和 <code>domain</code> 匹配，可以使用 <code>0</code>。</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li>成功：返回一个文件描述符（非负整数），表示新创建的套接字。</li>
<li>失败：返回 <code>-1</code>，并设置 <code>errno</code> 以指示错误类型。</li>
</ul>
<p>创建出来的socket，自带读写两个管道</p>
<p>服务端需要暴露出IP和端口，客户端不用，所以服务端必须bind，客户端可以bind，不推荐</p>
<p>因为客户端不bind可以无视<code>TIME_WAIT </code>,在 TCP 协议中，当一方主动关闭连接时，连接会进入 <strong>TIME_WAIT</strong> 状态。 如果客户端不调用 <code>bind()</code>，操作系统会为套接字分配一个临时端口（ephemeral port）。  如果连接关闭，且临时端口进入了 <code>TIME_WAIT</code> 状态，系统会避免分配到同一个端口，而是选择新的临时端口。 </p>
<p><strong>bind函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>功能：</strong></p>
<ul>
<li>将指定的 IP 地址和端口绑定到套接字。</li>
<li>常用于服务器程序，绑定特定的网络接口和端口以接收客户端的连接请求。</li>
</ul>
<p><strong><code>addr</code></strong>:</p>
<ul>
<li>指向 <strong><code>struct sockaddr</code></strong> 类型的指针，指定服务器的 IP 地址和端口。</li>
<li>对于 IPv4 通信，通常是 <code>struct sockaddr_in</code>，通过强制转换为 <code>struct sockaddr *</code>。（注意要强制转换，配合长度让Bind知道是什么类型）</li>
</ul>
<p><strong>connect函数</strong></p>
<p>客户端调用，建立连接</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p>功能：</p>
<ul>
<li>主动发起连接到指定的服务器（远程主机）。</li>
<li>用于客户端程序，建立到服务器的连接。</li>
</ul>
<p><strong>listen函数</strong></p>
<p>在 Linux 网络编程中，<code>listen</code> 函数是一个用于在服务器端设置待接收连接的函数，通常在创建套接字后使用。它的主要作用是将一个套接字设置为被动监听状态，等待客户端连接。 </p>
<p>调用listen以后，这个socket只能用来建立连接</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure>



<p>参数说明</p>
<ul>
<li><strong>sockfd</strong>：是之前通过 <code>socket()</code> 系统调用创建的套接字描述符，它用于标识该套接字。</li>
<li><strong>backlog</strong>：定义了可以排队等待连接的最大数量。如果有多个客户端尝试连接服务器，且服务器的接受队列已满，连接请求会被拒绝或被丢弃。通常值设置为一个合理的整数，常见的设置是 5 或 10，具体数值依赖于应用的需求。</li>
</ul>
<p>listen这个函数比较复杂：</p>
<p>进入listen后，它会重建内部的数据结构， 销毁 SND 和 RCV 缓冲区 ， 创建半连接队列和全连接队列 </p>
<p><code>listen()</code> 后的处理过程 </p>
<p>当服务器调用 <code>listen()</code> 后，服务器的监听套接字进入了被动监听模式。此时，套接字不再用于主动发送和接收数据，而是进入了连接管理模式，专门用于等待客户端的连接请求。<strong>SND</strong> 和 <strong>RCV</strong> 缓冲区被销毁，替换为用于连接管理的队列（半连接队列和全连接队列）。</p>
<p><strong>第一次握手</strong>（客户端发送 SYN）： </p>
<p>此时，服务器的监听套接字接收到这个连接请求，但并没有直接与客户端交换数据。<strong>此时服务器没有数据缓冲区</strong>（没有 <strong>SND</strong> 和 <strong>RCV</strong> 缓冲区），但是服务器的内核会在监听套接字的 <strong>半连接队列</strong> 中暂存这个连接请求。</p>
<p><strong>第二次握手</strong>（服务器发送 SYN-ACK）： </p>
<p>服务器收到客户端的 <strong>SYN</strong> 包后，服务器会向客户端发送一个 <strong>SYN-ACK</strong> 包，表示愿意接受连接，并等待客户端的确认。<strong>此时服务器确实没有用到传统的 SND 和 RCV 缓冲区</strong>，但它会使用操作系统内核中的 <strong>网络栈</strong> 来处理这些控制包的发送和接收。 </p>
<p><strong>第三次握手</strong>（客户端发送 ACK）： </p>
<p>客户端收到 <strong>SYN-ACK</strong> 后，会向服务器发送一个 <strong>ACK</strong> 包，表示连接建立完成。这时，客户端和服务器的连接正式建立，服务器会从 <strong>半连接队列</strong> 中移除这个连接，并将它移到 <strong>全连接队列</strong> 中，等待服务器应用程序通过 <code>accept()</code> 来接受这个连接。</p>
<p> 一旦连接建立，操作系统会为该连接分配一个新的套接字（<strong>已经拥有 SND 和 RCV 缓冲区</strong>），并开始为该套接字分配数据缓冲区，用于数据传输。 </p>
<p><strong>accept</strong></p>
<p>我们知道，之前由于调用listen，socket的SND,RCV缓冲区已经被删除掉了，建立好连接后，我们应该需要重建SND和RCV这俩管道发送信息</p>
<p> <code>accept</code> 是一个用于服务器程序的系统调用，它从服务器的 <strong>全连接队列</strong> 中取出一个已经完成三次握手的连接，并返回一个新的套接字（用于与客户端通信）。这个新的套接字与原来的监听套接字是分开的，新的套接字专用于和该客户端的数据通信，而监听套接字仍然负责监听新的连接请求。 </p>
<p>此时新的套接字就拥有<strong>SND和RCV</strong>缓冲区</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong></p>
<ol>
<li><strong><code>sockfd</code></strong>:<ul>
<li>一个已经调用了 <code>socket()</code> 和 <code>bind()</code> 并设置了监听状态的套接字描述符。</li>
<li>它是服务器的监听套接字。</li>
</ul>
</li>
<li><strong><code>addr</code></strong>:<ul>
<li>用于存储客户端的地址信息。</li>
<li>是一个指向 <code>sockaddr</code> 结构的指针，可以通过它获取客户端的 IP 地址和端口号。</li>
<li>如果你不关心客户端的地址信息，可以传 <code>NULL</code>。</li>
</ul>
</li>
<li><strong><code>addrlen</code></strong>:<ul>
<li>是一个指向 <code>socklen_t</code> 类型变量的指针，表示 <code>addr</code> 的大小。</li>
<li>函数返回时，它会被设置为实际的地址长度。</li>
<li>如果 <code>addr</code> 为 <code>NULL</code>，可以将 <code>addrlen</code> 也设置为 <code>NULL</code>。</li>
</ul>
</li>
</ol>
<p><strong>addrlen这个参数有点奇葩，这玩意一开始指向的值不能为空，得是可能的长度最大值</strong>，另外addr和addrlen全都是NULL，否则都要填写。</p>
<p>如下面的代码，listen是一个持续的过程，accept是阻塞的过程 ，**<code>listen()</code>** 看作是让服务器的套接字进入监听状态，而 <strong><code>accept()</code></strong> 则是不断接受连接请求并处理它们。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> server_fd, new_socket;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line">    <span class="type">int</span> addrlen = <span class="built_in">sizeof</span>(address);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建服务器监听套接字</span></span><br><span class="line">    <span class="keyword">if</span> ((server_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>(PORT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定套接字</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="built_in">sizeof</span>(address)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始监听，设置最大队列长度为3</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(server_fd, <span class="number">3</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Waiting for connections...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务器不断接受新的连接</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 等待并接受连接请求</span></span><br><span class="line">        <span class="keyword">if</span> ((new_socket = <span class="built_in">accept</span>(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, (<span class="type">socklen_t</span>*)&amp;addrlen)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;accept failed&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 客户端已连接，进行通信</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;New connection accepted\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送欢迎消息给客户端</span></span><br><span class="line">        <span class="type">char</span> *message = <span class="string">&quot;Hello from server!&quot;</span>;</span><br><span class="line">        <span class="built_in">send</span>(new_socket, message, <span class="built_in">strlen</span>(message), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭与客户端的连接</span></span><br><span class="line">        <span class="built_in">close</span>(new_socket);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<p><strong>send函数</strong></p>
<p>send函数的作用并不是发送，而是将数据拷贝到SND缓冲区，真正发送由内核协议栈发送，send的功能类似write，甚至功能更弱</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong></p>
<ol>
<li>**<code>sockfd</code>**：<ul>
<li>已经建立连接的套接字描述符。</li>
<li>由 <code>socket()</code> 创建并通过 <code>connect()</code>（客户端）或 <code>accept()</code>（服务端）建立连接。</li>
</ul>
</li>
<li>**<code>buf</code>**：<ul>
<li>指向要发送数据的缓冲区的指针。</li>
</ul>
</li>
<li>**<code>len</code>**：<ul>
<li>要发送的数据长度（单位：字节）。</li>
</ul>
</li>
<li>**<code>flags</code>**：<ul>
<li>指定数据传输的选项，常用值：<ul>
<li><code>0</code>：普通模式。</li>
<li><code>MSG_DONTWAIT</code>：非阻塞发送。</li>
<li><code>MSG_OOB</code>：发送紧急数据。</li>
<li><code>MSG_NOSIGNAL</code>：避免向断开的连接发送信号（防止进程崩溃）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>返回值</strong></p>
<ul>
<li>成功：<ul>
<li>返回实际发送的字节数。</li>
</ul>
</li>
<li>失败：<ul>
<li>返回 <code>-1</code>，设置 <code>errno</code> 指示错误原因（如连接断开、套接字非阻塞等）。</li>
</ul>
</li>
</ul>
<p><strong>recv 函数</strong> </p>
<p>作用不是接收，而是将数据从内核缓冲区拷贝到用户态的buf</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong></p>
<ol>
<li>**<code>sockfd</code>**：<ul>
<li>已经建立连接的套接字描述符。</li>
<li>数据从这个套接字接收。</li>
</ul>
</li>
<li>**<code>buf</code>**：<ul>
<li>指向用于存储接收数据的缓冲区的指针。</li>
</ul>
</li>
<li>**<code>len</code>**：<ul>
<li>缓冲区的大小（单位：字节）。</li>
</ul>
</li>
<li>**<code>flags</code>**：<ul>
<li>指定数据接收的选项，常用值：<ul>
<li><code>0</code>：普通模式。</li>
<li><code>MSG_PEEK</code>：查看数据但不移除（数据仍然留在接收缓冲区）。</li>
<li><code>MSG_WAITALL</code>：阻塞直到接收到指定长度的数据。</li>
<li><code>MSG_DONTWAIT</code>：非阻塞接收。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>返回值</strong></p>
<ul>
<li>成功：<ul>
<li>返回实际接收到的字节数。</li>
<li>如果返回 <code>0</code>，表示连接被对方关闭。</li>
</ul>
</li>
<li>失败：<ul>
<li>返回 <code>-1</code>，设置 <code>errno</code> 指示错误原因。</li>
</ul>
</li>
</ul>
<p><strong>select函数</strong></p>
<p>函数原型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p> <strong><code>nfds</code></strong>:  类型：<code>int</code>  说明：这是文件描述符的范围，应该设置为你关注的最大文件描述符加 1（即 <code>max_fd + 1</code>）。 </p>
<p> <strong><code>readfds</code></strong>:  指向一个 <code>fd_set</code> 类型的结构体，<code>select()</code> 会检查这些文件描述符是否有可读事件发生（例如，套接字是否有数据可以读取）。 </p>
<p> <strong><code>writefds</code></strong>:  指向一个 <code>fd_set</code> 类型的结构体，<code>select()</code> 会检查这些文件描述符是否有可写事件（例如，套接字是否可写入数据）。 </p>
<p> <strong><code>exceptfds</code></strong>:  说明：指向一个 <code>fd_set</code> 类型的结构体，<code>select()</code> 会检查这些文件描述符是否有异常事件（例如，网络连接是否断开，或者套接字上是否有错误发生）。 </p>
<p> <strong><code>timeout</code></strong>:  <code>timeout</code> 是一个 <code>struct timeval</code> 结构体，表示等待事件发生的最大时间。如果指定为 <code>NULL</code>，<code>select()</code> 将会无限期地等待，直到某个文件描述符准备好。否则，<code>select()</code> 将会在指定的时间内等待事件发生，超时则返回。 </p>
<p>如果服务端同时受理多个客户端，且没有开启多线程，那么就会有一个很尬的问题，你得一直轮询查看哪个端口来数据了，就像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 轮询每个客户端套接字，检查是否有数据可读</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; max_clients; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (client_sockets[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">char</span> buffer[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="type">int</span> valread = <span class="built_in">recv</span>(client_sockets[i], buffer, <span class="built_in">sizeof</span>(buffer), MSG_DONTWAIT);</span><br><span class="line">                <span class="keyword">if</span> (valread &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Received from client %d: %s\n&quot;</span>, i, buffer);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 发送回显消息</span></span><br><span class="line">                    <span class="type">char</span> *response = <span class="string">&quot;Message received&quot;</span>;</span><br><span class="line">                    <span class="built_in">send</span>(client_sockets[i], response, <span class="built_in">strlen</span>(response), <span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (valread == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 客户端关闭连接</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Client %d disconnected\n&quot;</span>, i);</span><br><span class="line">                    <span class="built_in">close</span>(client_sockets[i]);</span><br><span class="line">                    client_sockets[i] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 休眠片刻，避免浪费CPU资源</span></span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">10000</span>); <span class="comment">// 10ms</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<p>但是如果用了select， 就可以使用 select 实现多客户端管理 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CLIENTS 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> server_fd, new_socket, client_sockets[MAX_CLIENTS], max_clients = MAX_CLIENTS, max_sd;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line">    <span class="type">int</span> addrlen = <span class="built_in">sizeof</span>(address);</span><br><span class="line"></span><br><span class="line">    fd_set readfds; <span class="comment">// 用于 select 的文件描述符集合</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建服务器监听套接字</span></span><br><span class="line">    <span class="keyword">if</span> ((server_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>(PORT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定套接字</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="built_in">sizeof</span>(address)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始监听，设置最大队列长度为3</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(server_fd, <span class="number">3</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Waiting for connections...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化客户端套接字数组，全部设置为0（表示空闲）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; max_clients; i++) &#123;</span><br><span class="line">        client_sockets[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">FD_ZERO</span>(&amp;readfds); <span class="comment">// 清空集合</span></span><br><span class="line">        <span class="built_in">FD_SET</span>(server_fd, &amp;readfds); <span class="comment">// 将服务器套接字加入集合</span></span><br><span class="line">        max_sd = server_fd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将所有有效的客户端套接字加入集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; max_clients; i++) &#123;</span><br><span class="line">            <span class="type">int</span> sd = client_sockets[i];</span><br><span class="line">            <span class="keyword">if</span> (sd &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">FD_SET</span>(sd, &amp;readfds);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sd &gt; max_sd) &#123;</span><br><span class="line">                max_sd = sd; <span class="comment">// 找到最大的文件描述符</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 select 等待任一套接字状态变化</span></span><br><span class="line">        <span class="type">int</span> activity = <span class="built_in">select</span>(max_sd + <span class="number">1</span>, &amp;readfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (activity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;select error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否有新连接请求</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(server_fd, &amp;readfds)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((new_socket = <span class="built_in">accept</span>(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, (<span class="type">socklen_t</span> *)&amp;addrlen)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;accept failed&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;New connection accepted\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将新连接加入客户端数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; max_clients; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (client_sockets[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    client_sockets[i] = new_socket;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Adding new client to slot %d\n&quot;</span>, i);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查现有客户端是否有数据可读</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; max_clients; i++) &#123;</span><br><span class="line">            <span class="type">int</span> sd = client_sockets[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(sd, &amp;readfds)) &#123;</span><br><span class="line">                <span class="type">char</span> buffer[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="type">int</span> valread = <span class="built_in">recv</span>(sd, buffer, <span class="built_in">sizeof</span>(buffer), <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (valread &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Received from client %d: %s\n&quot;</span>, i, buffer);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 发送回显消息</span></span><br><span class="line">                    <span class="type">char</span> *response = <span class="string">&quot;Message received&quot;</span>;</span><br><span class="line">                    <span class="built_in">send</span>(sd, response, <span class="built_in">strlen</span>(response), <span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (valread == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 客户端关闭连接</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Client %d disconnected\n&quot;</span>, i);</span><br><span class="line">                    <span class="built_in">close</span>(sd);</span><br><span class="line">                    client_sockets[i] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>与 <code>select</code> 相关的宏</strong> </p>
<p><strong>FD_ISSET</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<p><code>fd</code>：要检查的文件描述符。</p>
<p><code>set</code>：一个 <code>fd_set</code> 类型的集合，通常由 <code>select</code> 或 <code>pselect</code> 填充。它包含了多个文件描述符。</p>
<p><strong>返回值</strong>： </p>
<p>如果文件描述符 <code>fd</code> 在集合 <code>set</code> 中处于活动状态（即有事件发生，如可读、可写、异常等），<code>FD_ISSET</code> 返回非零值（通常是 <code>1</code>）。</p>
<p>如果文件描述符 <code>fd</code> 没有在集合 <code>set</code> 中处于活动状态，返回 <code>0</code>。</p>
<p>还有以下几种</p>
<p>*<em>FD_SET(fd, fd_set <em>set)</em></em> ： <strong>作用</strong>：将文件描述符 <code>fd</code> 添加到文件描述符集合 <code>set</code> 中。 </p>
<p>**FD_CLR(fd, fd_set *set) **： <strong>作用</strong>：将文件描述符 <code>fd</code> 从文件描述符集合 <code>set</code> 中移除。 </p>
<p>*<em>FD_ZERO(fd_set <em>set)</em></em> ： <strong>作用</strong>：清空文件描述符集合 <code>set</code>。 </p>
<h2 id="断线重连"><a href="#断线重连" class="headerlink" title="断线重连"></a>断线重连</h2><p>如果客户端处于 <code>TIME_WAIT</code> 状态并显式使用 <code>bind</code> 绑定到同一个端口，则会出错。 当然，服务端也是一样的</p>
<p>客户端&#x2F;服务端在服务端断开连接后，尝试重新绑定（<code>bind</code>）时出现错误，这是因为此时客户端处于<code>TIME_WAIT</code>的状态</p>
<p><code>TIME_WAIT</code> 状态确保所有的连接数据完全清除，以防止新的连接复用相同的端口并收到之前连接的数据包。 </p>
<p><code>setsockopt</code> 是一个用于设置套接字选项的系统调用函数。它允许开发者调整套接字的行为，例如设置端口复用、超时、缓冲区大小等。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong></p>
<ol>
<li><p><strong><code>sockfd</code></strong></p>
<ul>
<li>表示套接字描述符，由 <code>socket()</code> 函数创建。</li>
<li>指定需要设置选项的套接字。</li>
</ul>
</li>
<li><p><strong><code>level</code></strong></p>
<ul>
<li>设置选项所属的协议层，通常是以下值之一：<ul>
<li>**<code>SOL_SOCKET</code>**：通用套接字选项。</li>
<li>**<code>IPPROTO_TCP</code>**：TCP 协议相关选项。</li>
<li>**<code>IPPROTO_IP</code>**：IPv4 协议相关选项。</li>
<li>**<code>IPPROTO_IPV6</code>**：IPv6 协议相关选项。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>optname</code></strong></p>
<ul>
<li><p>指定要设置的选项名称，其含义由 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">level</span><br></pre></td></tr></table></figure>

<p> 决定：</p>
<ul>
<li>通用选项（<code>SOL_SOCKET</code>）：<ul>
<li><code>SO_REUSEADDR</code>：允许端口复用。</li>
<li><code>SO_KEEPALIVE</code>：启用 TCP 保活。</li>
<li><code>SO_RCVBUF</code>：设置接收缓冲区大小。</li>
<li><code>SO_SNDBUF</code>：设置发送缓冲区大小。</li>
<li><code>SO_RCVTIMEO</code>：接收超时时间。</li>
<li><code>SO_SNDTIMEO</code>：发送超时时间。</li>
</ul>
</li>
<li>TCP 选项（<code>IPPROTO_TCP</code>）：<ul>
<li><code>TCP_NODELAY</code>：禁用 Nagle 算法（减少延迟）。</li>
<li><code>TCP_MAXSEG</code>：设置最大 TCP 段大小。</li>
<li><code>TCP_KEEPIDLE</code>：设置保活探测的空闲时间。</li>
<li><code>TCP_KEEPINTVL</code>：设置保活探测之间的间隔时间。</li>
<li><code>TCP_KEEPCNT</code>：设置保活探测的最大重试次数。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>optval</code></strong></p>
<ul>
<li><p>指向包含选项值的缓冲区。具体值类型取决于 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">optname</span><br></pre></td></tr></table></figure>

<p> 和协议：</p>
<ul>
<li>布尔值选项：<code>int</code> 类型。</li>
<li>超时选项：<code>struct timeval</code> 类型。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>optlen</code></strong></p>
<ul>
<li><code>optval</code> 指向数据的大小（字节数），通常是 <code>sizeof(optval)</code>。</li>
</ul>
</li>
</ol>
<p>允许端口复用：这样可以无视<code>TIME_WAIT</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">setsockopt</span>(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="built_in">sizeof</span>(opt)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;setsockopt(SO_REUSEADDR) failed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p><strong>支持断线重连的服务端，客户端代码：</strong></p>
<p>服务端</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080        <span class="comment">// 服务器监听的端口号</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 4096    <span class="comment">// 缓冲区大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> server_fd, client_fd = <span class="number">-1</span>;  <span class="comment">// 服务端socket和客户端socket文件描述符</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server_addr, client_addr;  <span class="comment">// 服务端和客户端的地址结构</span></span><br><span class="line">    fd_set monitor_set, ready_set;  <span class="comment">// 文件描述符集合：监控集合和就绪集合</span></span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE] = &#123; <span class="number">0</span> &#125;;       <span class="comment">// 缓冲区，用于接收客户端的数据</span></span><br><span class="line">    <span class="type">socklen_t</span> addr_len = <span class="built_in">sizeof</span>(client_addr);  <span class="comment">// 客户端地址结构的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建服务端socket（使用IPv4，TCP协议）</span></span><br><span class="line">    <span class="keyword">if</span> ((server_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Socket creation failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置地址复用，避免TIME_WAIT状态导致bind失败</span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">setsockopt</span>(server_fd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="built_in">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置服务器地址信息</span></span><br><span class="line">    server_addr.sin_family = AF_INET;          <span class="comment">// IPv4</span></span><br><span class="line">    server_addr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 监听所有可用的网络接口</span></span><br><span class="line">    server_addr.sin_port = <span class="built_in">htons</span>(PORT);        <span class="comment">// 转换端口为网络字节序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定地址到服务端socket</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(server_fd, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="built_in">sizeof</span>(server_addr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Bind failed&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(server_fd);  <span class="comment">// 关闭socket以释放资源</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始监听，允许最多5个待处理的连接</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(server_fd, <span class="number">5</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Listen failed&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(server_fd);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Server is listening on port %d...\n&quot;</span>, PORT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化监视集合</span></span><br><span class="line">    <span class="built_in">FD_ZERO</span>(&amp;monitor_set);            <span class="comment">// 清空监视集合</span></span><br><span class="line">    <span class="built_in">FD_SET</span>(server_fd, &amp;monitor_set);  <span class="comment">// 将服务端socket加入监视集合</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 每次循环都将monitor_set复制到ready_set（因为select会修改ready_set）</span></span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;ready_set, &amp;monitor_set, <span class="built_in">sizeof</span>(monitor_set));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用select监听文件描述符的状态变化</span></span><br><span class="line">        <span class="comment">//当 新的客户端连接（比如通过 accept()）到达时，监听套接字会变为可读状态。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">select</span>(FD_SETSIZE, &amp;ready_set, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;Select failed&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// 如果select出错，退出循环</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测服务端socket是否有新的连接到来</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(server_fd, &amp;ready_set)) &#123;</span><br><span class="line">            client_fd = <span class="built_in">accept</span>(server_fd, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;addr_len);</span><br><span class="line">            <span class="keyword">if</span> (client_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;Accept failed&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;  <span class="comment">// 如果accept失败，继续等待下一个连接</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Client connected\n&quot;</span>);</span><br><span class="line">            <span class="built_in">FD_SET</span>(client_fd, &amp;monitor_set);  <span class="comment">// 将新连接加入监视集合</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测客户端socket是否有数据可读</span></span><br><span class="line">        <span class="keyword">if</span> (client_fd != <span class="number">-1</span> &amp;&amp; <span class="built_in">FD_ISSET</span>(client_fd, &amp;ready_set)) &#123;</span><br><span class="line">            <span class="built_in">bzero</span>(buf, BUF_SIZE);  <span class="comment">// 清空缓冲区</span></span><br><span class="line">            <span class="type">ssize_t</span> len = <span class="built_in">recv</span>(client_fd, buf, BUF_SIZE, <span class="number">0</span>);  <span class="comment">// 接收客户端数据</span></span><br><span class="line">            <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;  <span class="comment">// 客户端断开连接或出错</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Client disconnected\n&quot;</span>);</span><br><span class="line">                <span class="built_in">close</span>(client_fd);  <span class="comment">// 关闭客户端socket</span></span><br><span class="line">                <span class="built_in">FD_CLR</span>(client_fd, &amp;monitor_set);  <span class="comment">// 从监视集合中移除</span></span><br><span class="line">                client_fd = <span class="number">-1</span>;  <span class="comment">// 重置client_fd</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Received: %s\n&quot;</span>, buf);  <span class="comment">// 打印接收到的消息</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(server_fd);  <span class="comment">// 关闭服务端socket</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p>客户端</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080          <span class="comment">// 服务端端口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_IP <span class="string">&quot;127.0.0.1&quot;</span>  <span class="comment">// 服务端IP地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 4096      <span class="comment">// 缓冲区大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server_addr;</span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备服务端地址结构</span></span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = <span class="built_in">htons</span>(PORT);</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, SERVER_IP, &amp;server_addr.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建socket</span></span><br><span class="line">        <span class="keyword">if</span> ((sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;Socket creation failed&quot;</span>);</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">5</span>);  <span class="comment">// 创建失败，稍后重试</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试连接到服务端</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">connect</span>(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="built_in">sizeof</span>(server_addr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;Connect failed, retrying...&quot;</span>);</span><br><span class="line">            <span class="built_in">close</span>(sockfd);  <span class="comment">// 关闭socket，避免资源泄漏</span></span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">5</span>);       <span class="comment">// 连接失败，稍后重试</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Connected to server!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通信循环</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 向服务端发送数据</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Enter message: &quot;</span>);</span><br><span class="line">            <span class="built_in">fgets</span>(buf, BUF_SIZE, stdin);</span><br><span class="line">            <span class="built_in">send</span>(sockfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 接收服务端数据</span></span><br><span class="line">            <span class="type">ssize_t</span> len = <span class="built_in">recv</span>(sockfd, buf, BUF_SIZE, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;  <span class="comment">// 连接中断</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Connection lost, reconnecting...\n&quot;</span>);</span><br><span class="line">                <span class="built_in">close</span>(sockfd);  <span class="comment">// 关闭socket</span></span><br><span class="line">                <span class="keyword">break</span>;          <span class="comment">// 跳出通信循环，尝试重连</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            buf[len] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// 确保字符串以\0结尾</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Server: %s\n&quot;</span>, buf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

















<h1 id="Windows下网络编程"><a href="#Windows下网络编程" class="headerlink" title="Windows下网络编程"></a>Windows下网络编程</h1><p>&#x2F;&#x2F;</p>
<h1 id="跨平台网络编程"><a href="#跨平台网络编程" class="headerlink" title="跨平台网络编程"></a>跨平台网络编程</h1><h2 id="远控项目"><a href="#远控项目" class="headerlink" title="远控项目"></a>远控项目</h2><p>可以去看远控项目： <a target="_blank" rel="noopener" href="https://blog.csdn.net/sumkee911/article/details/53709689">从零开始做远控 簡介篇 做一个属于你自己的远控_zeronet qt-CSDN博客</a> </p>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>TcpServer类:<br>1.首先我们新建一个TcpServer的类，继承于QObject，然后把QTcpServer include进来，记得要在你的.pro文件里Qt +&#x3D; network，不然你是无法使用网络库的。<br>2.我们的TcpServer是给多个类调用的，所以要以接口的方式编写，意思就是要其他类也能方便的调用它。<br>3.一旦有新连接，他就会将新连接的socket用信号发射给调用他的类</p>
<p>TcpServer.h </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TCPSERVER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCPSERVER_H</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTcpServer&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TcpServer</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">TcpServer</span><span class="params">(QObject *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 启动服务端</span></span><br><span class="line">    <span class="comment">// @port: 监听的端口</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">(<span class="type">int</span> port)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 反回服务器</span></span><br><span class="line">    <span class="function">QTcpServer *<span class="title">server</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mServer;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QTcpServer *mServer;  <span class="comment">// 在构造函数里初始化</span></span><br><span class="line"> </span><br><span class="line">signals:</span><br><span class="line">    <span class="comment">// 当新的连接进来时发送的信号</span></span><br><span class="line">    <span class="comment">// @sock: 新的连接</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">newConnection</span><span class="params">(QTcpSocket *sock)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="comment">// 当有从mServer中接收到新连接后，获取新连接的socket，然后再</span></span><br><span class="line">    <span class="comment">// 发射newConnection信号</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">newConnection</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// TCPSERVER_H</span></span></span><br></pre></td></tr></table></figure>



<p>TcpServer.cpp </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tcpserver.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line">TcpServer::<span class="built_in">TcpServer</span>(QObject *parent) : <span class="built_in">QObject</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    mServer = <span class="keyword">new</span> <span class="built_in">QTcpServer</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(mServer, <span class="built_in">SIGNAL</span>(<span class="built_in">newConnection</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">newConnection</span>()));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::start</span><span class="params">(<span class="type">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mServer-&gt;<span class="built_in">isListening</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mServer-&gt;<span class="built_in">listen</span>(QHostAddress::AnyIPv4, port)) &#123;</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;服务端监听成功&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;服务端监听失败：&quot;</span> &lt;&lt; mServer-&gt;<span class="built_in">errorString</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mServer-&gt;<span class="built_in">isListening</span>()) &#123;</span><br><span class="line">        mServer-&gt;<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::newConnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (mServer-&gt;<span class="built_in">hasPendingConnections</span>()) &#123;</span><br><span class="line">        <span class="comment">// 获取新连接</span></span><br><span class="line">        QTcpSocket *sock = mServer-&gt;<span class="built_in">nextPendingConnection</span>();</span><br><span class="line">        <span class="comment">// 发射新连接信号让调用服务器的类知道</span></span><br><span class="line">        <span class="function">emit <span class="title">newConnection</span><span class="params">(sock)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>TcpSocket类:<br>1.我们再建立一个TcpSocket的类，继承于QObject，然后把QTcpSocket include进来。<br>2.它和TcpServer一样也重复调用的，也是以接口的方式编写。<br>3.socket是用来和客户通信的桥梁，所以它主要实现读写数据的功能<br>4.一旦从客户里接收到数据，他就会将接收到数据的信号发射给调用他的类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TCPSOCKET_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCPSOCKET_H</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTcpSocket&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QHostAddress&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TcpSocket</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 初始化socket</span></span><br><span class="line">    <span class="comment">// @sock: 把sock加到这个类mSock的私有变量中</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">TcpSocket</span><span class="params">(QTcpSocket *sock, QObject *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 获取socket</span></span><br><span class="line">    <span class="function">QTcpSocket *<span class="title">socket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mSock;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 获取缓存区</span></span><br><span class="line">    <span class="function">QByteArray *<span class="title">buffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;mBuf;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 断开和客户之间的连接</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(QByteArray data)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QTcpSocket *mSock;  <span class="comment">// 客户</span></span><br><span class="line">    QByteArray mBuf;    <span class="comment">// 数据缓冲区，从客户里接收到的数据都会先放在这里</span></span><br><span class="line"> </span><br><span class="line">signals:</span><br><span class="line">    <span class="comment">// 当有新数据加入到mBuf后就发射这个信号，让调用这个类的类知道，</span></span><br><span class="line">    <span class="comment">// 然后在对新的数据作出相应的处理</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">newData</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 当客户断开是发射的信号</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">disconnected</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">readReady</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// TCPSOCKET_H</span></span></span><br></pre></td></tr></table></figure>



<p> TcpSocket.cpp </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tcpsocket.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line">TcpSocket::<span class="built_in">TcpSocket</span>(QTcpSocket *sock, QObject *parent):</span><br><span class="line">    <span class="built_in">QObject</span>(parent), <span class="built_in">mSock</span>(sock)</span><br><span class="line">&#123;</span><br><span class="line">    mSock-&gt;<span class="built_in">setParent</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(mSock, <span class="built_in">SIGNAL</span>(<span class="built_in">readyRead</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">readReady</span>()));</span><br><span class="line">    <span class="built_in">connect</span>(mSock, <span class="built_in">SIGNAL</span>(<span class="built_in">disconnected</span>()), <span class="keyword">this</span>, <span class="built_in">SIGNAL</span>(<span class="built_in">disconnected</span>()));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 输出信息</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; mSock-&gt;<span class="built_in">peerAddress</span>().<span class="built_in">toString</span>() &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; mSock-&gt;<span class="built_in">peerPort</span>() &lt;&lt; <span class="string">&quot; 已连接上服务端&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpSocket::close</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mSock-&gt;<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpSocket::write</span><span class="params">(QByteArray data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mSock-&gt;<span class="built_in">write</span>(data);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!mSock-&gt;<span class="built_in">waitForBytesWritten</span>(<span class="number">3000</span>)) &#123;</span><br><span class="line">        <span class="comment">// 发送数据超时</span></span><br><span class="line">        <span class="built_in">close</span>();</span><br><span class="line">        <span class="function">emit <span class="title">disconnected</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 输出信息</span></span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; mSock-&gt;<span class="built_in">peerAddress</span>().<span class="built_in">toString</span>() &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; mSock-&gt;<span class="built_in">peerPort</span>()</span><br><span class="line">                 &lt;&lt; <span class="string">&quot; 写入失败：&quot;</span> &lt;&lt; mSock-&gt;<span class="built_in">errorString</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpSocket::readReady</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mBuf.<span class="built_in">append</span>(mSock-&gt;<span class="built_in">readAll</span>());</span><br><span class="line">    <span class="function">emit <span class="title">newData</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>ZeroClient类:<br>1.这个类组合了刚才的TcpSocket类，用来处理客户的信息：“登入，登出”等等，向客户发送指：“监控屏幕，监控键盘”等等。<br>2.制定两组指令，一组是服务端向客户发送的指令，一组是客户端向服务端发送的指令。<br>3.处理从客户端发送过来的数据；向客户端发送指令。<br>4.如果新的客户登入后，就把它加入到ZeroServer里显示在widget类里的客户列表mClientTable里;登出则相反。<br>5.本类也设置一个计时器，如果长时间未能收到登录的消息就会自动跟客户断开</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ZEROCLIENT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZEROCLIENT_H</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tcpsocket.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTimer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTcpSocket&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QHostAddress&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ZeroClient</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ZeroClient</span><span class="params">(QTcpSocket *sock, QObject *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 服务端向客户端发送的指令(你觉得有需要你也可以增加自己的指令)</span></span><br><span class="line">    <span class="type">const</span> QByteArray CmdScreenSpy = <span class="string">&quot;SCREEN_SPY&quot;</span>;</span><br><span class="line">    <span class="type">const</span> QByteArray CmdKeyboardSpy = <span class="string">&quot;KEYBOARD_SPY&quot;</span>;</span><br><span class="line">    <span class="type">const</span> QByteArray CmdFileSpy = <span class="string">&quot;FILE_SPY&quot;</span>;</span><br><span class="line">    <span class="type">const</span> QByteArray CmdCmdSpy = <span class="string">&quot;CMD_SPY&quot;</span>;</span><br><span class="line">    <span class="type">const</span> QByteArray CmdSendMessage = <span class="string">&quot;SEND_MESSAGE&quot;</span>;</span><br><span class="line">    <span class="type">const</span> QByteArray CmdReboot = <span class="string">&quot;REBOOT&quot;</span>;</span><br><span class="line">    <span class="type">const</span> QByteArray CmdQuit = <span class="string">&quot;QUIT&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 客户端向服务端发送的指令(你觉得有需要你也可以增加自己的指令)</span></span><br><span class="line">    <span class="type">const</span> QByteArray CmdLogin = <span class="string">&quot;LOGIN&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 分割符号和结束符号，比如登入命令:LOGIN&lt;分割符&gt;SYSTEM&lt;分割符&gt;Windows 7&lt;分割符&gt;USER_NAME&lt;分割符&gt;sumkee911&lt;结束符号&gt;</span></span><br><span class="line">    <span class="type">const</span> QByteArray CmdSplit = <span class="string">&quot;;&quot;</span>;</span><br><span class="line">    <span class="type">const</span> QByteArray CmdEnd = <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 断开客户</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">closeAndDelete</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 设置ID</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setId</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">        mId = id;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TcpSocket *mSock;       <span class="comment">// 与客户通讯的socket</span></span><br><span class="line">    QTimer *mLoginTimeout;  <span class="comment">// 用来判断客户是否超时登入</span></span><br><span class="line">    <span class="type">int</span> mId;                <span class="comment">// 初始值是-1, 登入后会由ZeroServer分配大于或等于0的ID号码</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 处理指令</span></span><br><span class="line">    <span class="comment">// @cmd: 指令</span></span><br><span class="line">    <span class="comment">// @args: 参数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">processCommand</span><span class="params">(QByteArray &amp;cmd, QByteArray &amp;args)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 分解指令的参数，反回哈希表</span></span><br><span class="line">    <span class="function">QHash&lt;QByteArray, QByteArray&gt; <span class="title">parseArgs</span><span class="params">(QByteArray &amp;args)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 各个指令相应的函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doLogin</span><span class="params">(QHash&lt;QByteArray, QByteArray&gt; &amp;args)</span></span>;</span><br><span class="line"> </span><br><span class="line">signals:</span><br><span class="line">    <span class="comment">// 登入和登出信号</span></span><br><span class="line">    <span class="comment">// @client: 自己</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">login</span><span class="params">(ZeroClient *client, QString userName, QString ip, <span class="type">int</span> port, QString system)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">logout</span><span class="params">(<span class="type">int</span> id)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="comment">// 如果客户在制定时间内还没有登入就踢了他</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clientLoginTimeout</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 客户断开</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">disconnected</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 接收新数据</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">newData</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// ZEROCLIENT_H</span></span></span><br></pre></td></tr></table></figure>





<p> ZeroClient.cpp </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;zeroclient.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line">ZeroClient::<span class="built_in">ZeroClient</span>(QTcpSocket *sock, QObject *parent) :</span><br><span class="line">    <span class="built_in">QObject</span>(parent), <span class="built_in">mId</span>(<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 设置socket</span></span><br><span class="line">    mSock = <span class="keyword">new</span> <span class="built_in">TcpSocket</span>(sock, <span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(mSock, <span class="built_in">SIGNAL</span>(<span class="built_in">newData</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">newData</span>()));</span><br><span class="line">    <span class="built_in">connect</span>(mSock, <span class="built_in">SIGNAL</span>(<span class="built_in">disconnected</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">disconnected</span>()));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 设置计时器来判断客户是否登入，如果没就断开连接</span></span><br><span class="line">    <span class="comment">// 我在这里设置10秒钟，很随意的，你想怎么设置都可以</span></span><br><span class="line">    mLoginTimeout = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(mLoginTimeout, <span class="built_in">SIGNAL</span>(<span class="built_in">timeout</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">clientLoginTimeout</span>()));</span><br><span class="line">    mLoginTimeout-&gt;<span class="built_in">start</span>(<span class="number">10</span>*<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ZeroClient::closeAndDelete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 输出信息</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; mSock-&gt;<span class="built_in">socket</span>()-&gt;<span class="built_in">peerAddress</span>().<span class="built_in">toString</span>() &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">             &lt;&lt; mSock-&gt;<span class="built_in">socket</span>()-&gt;<span class="built_in">peerPort</span>() &lt;&lt; <span class="string">&quot; 已经断开服务端&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    mSock-&gt;<span class="built_in">close</span>();</span><br><span class="line">    <span class="built_in">deleteLater</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ZeroClient::processCommand</span><span class="params">(QByteArray &amp;cmd, QByteArray &amp;args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cmd = cmd.<span class="built_in">toUpper</span>().<span class="built_in">trimmed</span>();</span><br><span class="line">    QHash&lt;QByteArray, QByteArray&gt; hashArgs = <span class="built_in">parseArgs</span>(args);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 登入指令</span></span><br><span class="line">    <span class="keyword">if</span> (cmd == CmdLogin &amp;&amp; mId == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">doLogin</span>(hashArgs);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">QHash&lt;QByteArray, QByteArray&gt; <span class="title">ZeroClient::parseArgs</span><span class="params">(QByteArray &amp;args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QList&lt;QByteArray&gt; listArgs = args.<span class="built_in">split</span>(CmdSplit[<span class="number">0</span>]);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 分解参数，然后把它加入哈希表</span></span><br><span class="line">    QHash&lt;QByteArray, QByteArray&gt; hashArgs;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;listArgs.<span class="built_in">length</span>()<span class="number">-1</span> ; i+=<span class="number">2</span>) &#123;</span><br><span class="line">        hashArgs.<span class="built_in">insert</span>(listArgs[i].<span class="built_in">toUpper</span>().<span class="built_in">trimmed</span>(),</span><br><span class="line">                        listArgs[i+<span class="number">1</span>].<span class="built_in">trimmed</span>());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> hashArgs;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ZeroClient::doLogin</span><span class="params">(QHash&lt;QByteArray, QByteArray&gt; &amp;args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 发射登录信号</span></span><br><span class="line">    QString userName = args[<span class="string">&quot;USER_NAME&quot;</span>];</span><br><span class="line">    QString system = args[<span class="string">&quot;SYSTEM&quot;</span>];</span><br><span class="line">    QString ip = mSock-&gt;<span class="built_in">socket</span>()-&gt;<span class="built_in">peerAddress</span>().<span class="built_in">toString</span>();</span><br><span class="line">    <span class="type">int</span> port = mSock-&gt;<span class="built_in">socket</span>()-&gt;<span class="built_in">peerPort</span>();</span><br><span class="line">    <span class="function">emit <span class="title">login</span><span class="params">(<span class="keyword">this</span>, userName, ip, port, system)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 输出信息</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; ip &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; port &lt;&lt; <span class="string">&quot; 已经登入服务端&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ZeroClient::clientLoginTimeout</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mId == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">closeAndDelete</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ZeroClient::disconnected</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mId &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function">emit <span class="title">logout</span><span class="params">(mId)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">closeAndDelete</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ZeroClient::newData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 从socket里获取缓存区</span></span><br><span class="line">    QByteArray *buf = mSock-&gt;<span class="built_in">buffer</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> endIndex;</span><br><span class="line">    <span class="keyword">while</span> ((endIndex = buf-&gt;<span class="built_in">indexOf</span>(CmdEnd)) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 提取一行指令</span></span><br><span class="line">        QByteArray data = buf-&gt;<span class="built_in">mid</span>(<span class="number">0</span>, endIndex);</span><br><span class="line">        buf-&gt;<span class="built_in">remove</span>(<span class="number">0</span>, endIndex + CmdEnd.<span class="built_in">length</span>());</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 提取指令和参数</span></span><br><span class="line">        QByteArray cmd, args;</span><br><span class="line">        <span class="type">int</span> argIndex = data.<span class="built_in">indexOf</span>(CmdSplit);</span><br><span class="line">        <span class="keyword">if</span> (argIndex == <span class="number">-1</span>) &#123;</span><br><span class="line">            cmd = data;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cmd = data.<span class="built_in">mid</span>(<span class="number">0</span>, argIndex);</span><br><span class="line">            args = data.<span class="built_in">mid</span>(argIndex+CmdSplit.<span class="built_in">length</span>(), data.<span class="built_in">length</span>());</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 处理指令</span></span><br><span class="line">        <span class="built_in">processCommand</span>(cmd, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p>ZeroServer类:<br>1.这个类组合了刚才的TcpServer和ZeroClient类，是ZeroServer项目的主要服务端，用来管理客户。<br>2.客户登入后给他们分配ID，并且把他们显示在窗口的mClientTable控件里；登出则反之。 </p>
<p> ZeroServer.h </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ZEROSERVER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZEROSERVER_H</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TcpServer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ZeroClient.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QHash&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ZeroServer</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ZeroServer</span><span class="params">(QObject *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 启动或停止服务端</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">(<span class="type">int</span> port)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 用id来获取ZeroClient</span></span><br><span class="line">    <span class="function">ZeroClient *<span class="title">client</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mClients[id];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TcpServer *mServer;         <span class="comment">// Tcp服务端</span></span><br><span class="line">    QHash&lt;<span class="type">int</span>, ZeroClient*&gt; mClients;  <span class="comment">// 用ID来索引相应的客户</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 生成新的id</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">generateId</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">signals:</span><br><span class="line">    <span class="comment">// 客户登入或登出，主要是告诉窗口控件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clientLogin</span><span class="params">(<span class="type">int</span> id, QString userName,</span></span></span><br><span class="line"><span class="params"><span class="function">                     QString ip,<span class="type">int</span> port, QString system)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clientLogout</span><span class="params">(<span class="type">int</span> id)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="comment">// 新客户连接</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">newConnection</span><span class="params">(QTcpSocket *sock)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 客户登入</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">login</span><span class="params">(ZeroClient*, QString userName,</span></span></span><br><span class="line"><span class="params"><span class="function">                  QString ip, <span class="type">int</span> port, QString system)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 客户登出</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">logout</span><span class="params">(<span class="type">int</span> id)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// ZEROSERVER_H</span></span></span><br></pre></td></tr></table></figure>



<p> ZeroServer.cpp </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;zeroserver.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line">ZeroServer::<span class="built_in">ZeroServer</span>(QObject *parent) : <span class="built_in">QObject</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化服务器</span></span><br><span class="line">    mServer = <span class="keyword">new</span> <span class="built_in">TcpServer</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(mServer, <span class="built_in">SIGNAL</span>(<span class="built_in">newConnection</span>(QTcpSocket*)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">newConnection</span>(QTcpSocket*)));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ZeroServer::start</span><span class="params">(<span class="type">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mServer-&gt;<span class="built_in">start</span>(port);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ZeroServer::stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mServer-&gt;<span class="built_in">stop</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ZeroServer::generateId</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> max = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 避免重复</span></span><br><span class="line">    QList&lt;<span class="type">int</span>&gt; existsKeys = mClients.<span class="built_in">keys</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=mClients.<span class="built_in">size</span>()+<span class="number">1</span>; i&lt;max; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (existsKeys.<span class="built_in">indexOf</span>(i) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ZeroServer::newConnection</span><span class="params">(QTcpSocket *sock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建ZeroClient，把sock添加进去</span></span><br><span class="line">    ZeroClient *client = <span class="keyword">new</span> <span class="built_in">ZeroClient</span>(sock);</span><br><span class="line">    <span class="built_in">connect</span>(client, <span class="built_in">SIGNAL</span>(<span class="built_in">login</span>(ZeroClient*,QString,QString,<span class="type">int</span>,QString)),</span><br><span class="line">            <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">login</span>(ZeroClient*,QString,QString,<span class="type">int</span>,QString)));</span><br><span class="line">    <span class="built_in">connect</span>(client, <span class="built_in">SIGNAL</span>(<span class="built_in">logout</span>(<span class="type">int</span>)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">logout</span>(<span class="type">int</span>)));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ZeroServer::login</span><span class="params">(ZeroClient *client, QString userName, QString ip, <span class="type">int</span> port, QString system)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 增加客户到哈希表</span></span><br><span class="line">    <span class="type">int</span> id = <span class="built_in">generateId</span>();</span><br><span class="line">    mClients.<span class="built_in">insert</span>(id, client);</span><br><span class="line">    client-&gt;<span class="built_in">setId</span>(id);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 发射登入信号给窗口控件</span></span><br><span class="line">    <span class="function">emit <span class="title">clientLogin</span><span class="params">(id, userName, ip, port, system)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ZeroServer::logout</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 从哈希表中删除客户</span></span><br><span class="line">    mClients.<span class="built_in">remove</span>(id);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 发射登出信号给窗口控件</span></span><br><span class="line">    <span class="function">emit <span class="title">clientLogout</span><span class="params">(id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="客户端："><a href="#客户端：" class="headerlink" title="客户端："></a>客户端：</h3><p>客户端代码和CSDN项目不同，主要区别是从windows的代码转为了QT的</p>
<p>TcpSocket类： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TCPSOCKET_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCPSOCKET_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTcpSocket&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QHostAddress&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QByteArray&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QHostInfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值结构体，包含 QByteArray 数据和错误码</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RecvResult</span> &#123;</span><br><span class="line">    QByteArray data;</span><br><span class="line">    <span class="type">int</span> errorCode;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TcpSocket</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TcpSocket</span>(QObject* parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">TcpSocket</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 域名转IP</span></span><br><span class="line">    <span class="function"><span class="type">static</span> QString <span class="title">fromDomainToIP</span><span class="params">(<span class="type">const</span> QString&amp; domain)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接，断开，发送，接收</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">connectTo</span><span class="params">(<span class="type">const</span> QString&amp; domain, <span class="type">int</span> port)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">disconnect</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">sendData</span><span class="params">(<span class="type">const</span> QByteArray&amp; data)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">recvData</span><span class="params">(QString&amp; receivedData)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">readReady</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否处于连接的状态</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isConnected</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    QTcpSocket* mSock;   <span class="comment">// socket</span></span><br><span class="line">    QByteArray buf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    QString mIp;          <span class="comment">// ip</span></span><br><span class="line">    <span class="type">int</span> mPort;            <span class="comment">// 端口</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="comment">// 当有新数据加入到mBuf后就发射这个信号，让调用这个类的类知道，</span></span><br><span class="line">    <span class="comment">// 然后在对新的数据作出相应的处理</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">newData</span><span class="params">(QString buf)</span></span>;</span><br><span class="line"><span class="comment">//signals:</span></span><br><span class="line"><span class="comment">//    // 用于转发连接成功信号</span></span><br><span class="line"><span class="comment">//    void connectedToHost();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//private slots:</span></span><br><span class="line"><span class="comment">//    // 连接成功时的槽函数</span></span><br><span class="line"><span class="comment">//    void onConnected() &#123;</span></span><br><span class="line"><span class="comment">//        // 在这里发出转发信号</span></span><br><span class="line"><span class="comment">//        emit connectedToHost();</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// TCPSOCKET_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p><strong>TcpSocket.cpp</strong> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TcpSocket.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">TcpSocket::<span class="built_in">TcpSocket</span>(QObject* parent): <span class="built_in">QObject</span>(parent), <span class="built_in">mSock</span>(<span class="keyword">new</span> <span class="built_in">QTcpSocket</span>(<span class="keyword">this</span>)), <span class="built_in">mPort</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">connect</span>(mSock, &amp;QTcpSocket::connected, <span class="keyword">this</span>, [<span class="keyword">this</span>]()</span><br><span class="line">        &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Connected to server!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">connect</span>(mSock, &amp;QTcpSocket::readyRead, <span class="keyword">this</span>, &amp;TcpSocket::readReady);</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(mSock, &amp;QTcpSocket::disconnected, <span class="keyword">this</span>, []() </span><br><span class="line">        &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Disconnected from server!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接 QTcpSocket 的 connected() 信号到槽函数</span></span><br><span class="line">    <span class="comment">//connect(mSock, &amp;QTcpSocket::connected, this, &amp;TcpSocket::onConnected);</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpSocket::readReady</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果没有数据，可以调用 waitForReadyRead 等待</span></span><br><span class="line">    <span class="keyword">if</span> (mSock-&gt;<span class="built_in">bytesAvailable</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 阻塞直到有数据可读，等待最多 1000 毫秒</span></span><br><span class="line">        <span class="keyword">if</span> (!mSock-&gt;<span class="built_in">waitForReadyRead</span>(<span class="number">10000</span>)) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Timeout or error: &quot;</span> &lt;&lt; mSock-&gt;<span class="built_in">errorString</span>().<span class="built_in">toStdString</span>() &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取数据</span></span><br><span class="line">    buf.<span class="built_in">append</span>(mSock-&gt;<span class="built_in">readAll</span>());</span><br><span class="line">    QString string = QString::<span class="built_in">fromUtf8</span>(buf);</span><br><span class="line">    <span class="comment">// 发射信号</span></span><br><span class="line">    <span class="function">emit <span class="title">newData</span><span class="params">(string)</span></span>;</span><br><span class="line">    buf.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line">TcpSocket::~<span class="built_in">TcpSocket</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isConnected</span>()) &#123;</span><br><span class="line">        mSock-&gt;<span class="built_in">disconnectFromHost</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QString <span class="title">TcpSocket::fromDomainToIP</span><span class="params">(<span class="type">const</span> QString&amp; domain)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QHostInfo hostInfo = QHostInfo::<span class="built_in">fromName</span>(domain);</span><br><span class="line">    <span class="keyword">if</span> (hostInfo.<span class="built_in">error</span>() == QHostInfo::NoError) &#123;</span><br><span class="line">        <span class="keyword">return</span> hostInfo.<span class="built_in">addresses</span>().<span class="built_in">first</span>().<span class="built_in">toString</span>();  <span class="comment">// 获取第一个IP地址</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to resolve domain!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">QString</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TcpSocket::connectTo</span><span class="params">(<span class="type">const</span> QString&amp; domain, <span class="type">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mIp = <span class="built_in">fromDomainToIP</span>(domain);</span><br><span class="line">    mPort = port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mIp.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to resolve domain&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mSock-&gt;<span class="built_in">connectToHost</span>(mIp, mPort);</span><br><span class="line">    <span class="keyword">return</span> mSock-&gt;<span class="built_in">waitForConnected</span>(<span class="number">5000</span>);  <span class="comment">// 等待连接，超时时间5秒</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpSocket::disconnect</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isConnected</span>()) &#123;</span><br><span class="line">        mSock-&gt;<span class="built_in">disconnectFromHost</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TcpSocket::sendData</span><span class="params">(<span class="type">const</span> QByteArray&amp; data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isConnected</span>()) &#123;</span><br><span class="line">        mSock-&gt;<span class="built_in">write</span>(data);</span><br><span class="line">        <span class="keyword">return</span> mSock-&gt;<span class="built_in">waitForBytesWritten</span>(<span class="number">3000</span>);  <span class="comment">// 等待数据发送完成</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpSocket::recvData</span><span class="params">(QString&amp; receivedData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 检查连接是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isConnected</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Socket not connected!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::<span class="built_in">fflush</span>(stdout);</span><br><span class="line">        receivedData.<span class="built_in">clear</span>();  <span class="comment">// 清空接收数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 返回 -1 表示没有连接</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化接收的数据</span></span><br><span class="line">    receivedData.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞直到有数据可读</span></span><br><span class="line">    <span class="keyword">while</span> (mSock-&gt;<span class="built_in">waitForReadyRead</span>(<span class="number">-1</span>)) &#123;  <span class="comment">// -1 表示无限等待</span></span><br><span class="line">        QByteArray data = mSock-&gt;<span class="built_in">readAll</span>();  <span class="comment">// 读取所有可用数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果读取的数据为空，则继续等待</span></span><br><span class="line">        <span class="keyword">if</span> (data.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 QByteArray 转换为 QString，并附加到接收数据中</span></span><br><span class="line">        receivedData.<span class="built_in">append</span>(QString::<span class="built_in">fromUtf8</span>(data));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果收到完整的数据，可以根据协议处理后跳出循环</span></span><br><span class="line">        <span class="comment">// 假设协议中数据以 &quot;\r\n&quot; 结束</span></span><br><span class="line">        <span class="keyword">if</span> (receivedData.<span class="built_in">contains</span>(<span class="string">&quot;\r\n&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果数据为空，断开连接</span></span><br><span class="line">    <span class="keyword">if</span> (receivedData.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to receive data or connection closed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::<span class="built_in">fflush</span>(stdout);</span><br><span class="line">        <span class="built_in">disconnect</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;  <span class="comment">// 返回 -2 表示读取数据失败</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 返回 0 表示成功接收到数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TcpSocket::isConnected</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mSock-&gt;<span class="built_in">state</span>() == QTcpSocket::ConnectedState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>ZeroClient类：<br>这个类是这个ZeroClient程序最主要的类，不断死循环，接收从服务端传过来的命令，比如：屏幕监控，键盘监控等等<br>1.首先创建一个ZeroClient类，然后把TcpSocket类include进来<br>2.把上一节定义的通讯协议复制到ZeroClient类的公有变量里</p>
<p><strong>ZeroClient.h</strong> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ZEROCLIENT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZEROCLIENT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QByteArray&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTcpSocket&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QProcessEnvironment&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TcpSocket.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDataStream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TimeData</span> &#123;</span><br><span class="line">    <span class="type">int</span> hour;</span><br><span class="line">    <span class="type">int</span> minute;</span><br><span class="line">    <span class="type">int</span> second;</span><br><span class="line">    <span class="type">int</span> millisecond;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ZeroClient</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ZeroClient</span>();</span><br><span class="line">    ~<span class="built_in">ZeroClient</span>();</span><br><span class="line"></span><br><span class="line">    QString mBuf;</span><br><span class="line">    TcpSocket mSock;    <span class="comment">// 与服务端连接的socket</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 服务端向客户端发送的指令</span></span><br><span class="line">    <span class="type">const</span> QString CmdScreenSpy = <span class="string">&quot;SCREEN_SPY&quot;</span>;</span><br><span class="line">    <span class="type">const</span> QString CmdKeyboardSpy = <span class="string">&quot;KEYBOARD_SPY&quot;</span>;</span><br><span class="line">    <span class="type">const</span> QString CmdFileSpy = <span class="string">&quot;FILE_SPY&quot;</span>;</span><br><span class="line">    <span class="type">const</span> QString CmdCmdSpy = <span class="string">&quot;CMD_SPY&quot;</span>;</span><br><span class="line">    <span class="type">const</span> QString CmdSendMessage = <span class="string">&quot;SEND_MESSAGE&quot;</span>;</span><br><span class="line">    <span class="type">const</span> QString CmdReboot = <span class="string">&quot;REBOOT&quot;</span>;</span><br><span class="line">    <span class="type">const</span> QString CmdQuit = <span class="string">&quot;QUIT&quot;</span>;</span><br><span class="line">    <span class="type">const</span> QString CmdGetTime = <span class="string">&quot;GET_TIME&quot;</span>;</span><br><span class="line">    <span class="comment">// 客户端向服务端发送的指令</span></span><br><span class="line">    <span class="type">const</span> QString CmdLogin = <span class="string">&quot;LOGIN&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分割符号和结束符号</span></span><br><span class="line">    <span class="type">const</span> QString CmdSplit = <span class="string">&quot;;&quot;</span>;</span><br><span class="line">    <span class="type">const</span> QString CmdEnd = <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//// 获取本机用户名和系统型号</span></span><br><span class="line">    <span class="comment">//std::string getUserName();</span></span><br><span class="line">    <span class="comment">//std::string getSystemModel();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送命令</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">sendLogin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据处理函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addDataToBuffer</span><span class="params">(QByteArray ret)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">processCmd</span><span class="params">(<span class="type">const</span> QString&amp; cmd, QString&amp; data)</span></span>;</span><br><span class="line">    <span class="function">std::map&lt;QString, QString&gt; <span class="title">parseArgs</span><span class="params">(QString&amp; data)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">connectTo</span><span class="params">(<span class="type">const</span> QString&amp; domain, <span class="type">int</span> port)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//// 相应于各个指令的处理函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doGetTime</span><span class="params">(std::map&lt;QString, QString&gt; args)</span></span>;</span><br><span class="line">    <span class="comment">//void doScreenSpy(std::map&lt;std::string, std::string&gt;&amp; args);</span></span><br><span class="line">    <span class="comment">//void doKeyboardSpy(std::map&lt;std::string, std::string&gt;&amp; args);</span></span><br><span class="line">    <span class="comment">//void doFileSpy(std::map&lt;std::string, std::string&gt;&amp; args);</span></span><br><span class="line">    <span class="comment">//void doCmdSpy(std::map&lt;std::string, std::string&gt;&amp; args);</span></span><br><span class="line">    <span class="comment">//void doSendMessage(std::map&lt;std::string, std::string&gt;&amp; args);</span></span><br><span class="line">    <span class="comment">//void doReboot(std::map&lt;std::string, std::string&gt;&amp; args);</span></span><br><span class="line">    <span class="comment">//void doQuit(std::map&lt;std::string, std::string&gt;&amp; args);</span></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">timeDataReceived</span><span class="params">(<span class="type">const</span> QString&amp; data)</span></span>;  <span class="comment">// 定义信号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onNewDataReceived</span><span class="params">(<span class="type">const</span> QString&amp; data)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// ZEROCLIENT_H</span></span></span><br></pre></td></tr></table></figure>





<p> <strong>ZeroClient.cpp</strong> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ZeroClient.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTcpSocket&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QByteArray&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line">ZeroClient::<span class="built_in">ZeroClient</span>()</span><br><span class="line">&#123;</span><br><span class="line">    QObject* parent = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接 TcpSocket 的 newData 信号到 ZeroClient 的槽函数 onNewDataReceived</span></span><br><span class="line">    <span class="built_in">connect</span>(&amp;mSock, &amp;TcpSocket::newData, <span class="keyword">this</span>, &amp;ZeroClient::onNewDataReceived);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ZeroClient::onNewDataReceived</span><span class="params">(<span class="type">const</span> QString&amp; data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 把数据加入到缓冲区</span></span><br><span class="line">    <span class="built_in">addDataToBuffer</span>(data.<span class="built_in">toUtf8</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ZeroClient::~<span class="built_in">ZeroClient</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ZeroClient::connectTo</span><span class="params">(<span class="type">const</span> QString&amp; domain, <span class="type">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 连接到服务端</span></span><br><span class="line">    <span class="keyword">if</span> (!mSock.<span class="built_in">connectTo</span>(domain, port)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送登入命令</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">sendLogin</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">QString <span class="title">getUserName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前用户的用户名</span></span><br><span class="line">    QString userName = QProcessEnvironment::<span class="built_in">systemEnvironment</span>().<span class="built_in">value</span>(<span class="string">&quot;USER&quot;</span>);  <span class="comment">// Unix 系统</span></span><br><span class="line">    <span class="keyword">if</span> (userName.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        userName = QProcessEnvironment::<span class="built_in">systemEnvironment</span>().<span class="built_in">value</span>(<span class="string">&quot;USERNAME&quot;</span>);  <span class="comment">// Windows 系统</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> userName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QString <span class="title">getSystemModel</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取操作系统的名称</span></span><br><span class="line">    QString osName = QSysInfo::<span class="built_in">prettyProductName</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断操作系统类型</span></span><br><span class="line">    <span class="keyword">if</span> (osName.<span class="built_in">contains</span>(<span class="string">&quot;Windows&quot;</span>, Qt::CaseInsensitive)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Windows&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (osName.<span class="built_in">contains</span>(<span class="string">&quot;Ubuntu&quot;</span>, Qt::CaseInsensitive)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Ubuntu&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//// GBK 转 UTF-8</span></span><br><span class="line"><span class="comment">//std::string GBKToUTF8(const std::string&amp; gbkStr) &#123;</span></span><br><span class="line"><span class="comment">//    int unicodeLen = MultiByteToWideChar(CP_ACP, 0, gbkStr.c_str(), -1, NULL, 0);</span></span><br><span class="line"><span class="comment">//    wchar_t* unicodeStr = new wchar_t[unicodeLen];</span></span><br><span class="line"><span class="comment">//    MultiByteToWideChar(CP_ACP, 0, gbkStr.c_str(), -1, unicodeStr, unicodeLen);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    int utf8Len = WideCharToMultiByte(CP_UTF8, 0, unicodeStr, -1, NULL, 0, NULL, NULL);</span></span><br><span class="line"><span class="comment">//    char* utf8Str = new char[utf8Len];</span></span><br><span class="line"><span class="comment">//    WideCharToMultiByte(CP_UTF8, 0, unicodeStr, -1, utf8Str, utf8Len, NULL, NULL);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    std::string result(utf8Str);</span></span><br><span class="line"><span class="comment">//    delete[] unicodeStr;</span></span><br><span class="line"><span class="comment">//    delete[] utf8Str;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    return result;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ZeroClient::sendLogin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 构建登入信息并发送给服务端</span></span><br><span class="line">    QString data;</span><br><span class="line">    data.<span class="built_in">append</span>(CmdLogin + CmdSplit);</span><br><span class="line">    data.<span class="built_in">append</span>(<span class="string">&quot;SYSTEM&quot;</span> + CmdSplit + <span class="built_in">getSystemModel</span>() + CmdSplit);</span><br><span class="line">    data.<span class="built_in">append</span>(<span class="string">&quot;USER_NAME&quot;</span> + CmdSplit + <span class="built_in">getUserName</span>());</span><br><span class="line">    data.<span class="built_in">append</span>(CmdEnd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将字符串从GBK转换为UTF-8</span></span><br><span class="line">    QByteArray dataUtf8 = data.<span class="built_in">toUtf8</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    <span class="keyword">return</span> mSock.<span class="built_in">sendData</span>(dataUtf8);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ZeroClient::addDataToBuffer</span><span class="params">(QByteArray ret)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString str = QString::<span class="built_in">fromUtf8</span>(ret);</span><br><span class="line">    mBuf.<span class="built_in">append</span>(str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把数据转换成指令模式</span></span><br><span class="line">    <span class="type">int</span> endIndex;</span><br><span class="line">    <span class="keyword">while</span> ((endIndex = mBuf.<span class="built_in">indexOf</span>(CmdEnd)) &gt;= <span class="number">0</span>) &#123;  <span class="comment">//找到/r/n就进行循环</span></span><br><span class="line">        QString line = mBuf.<span class="built_in">left</span>(endIndex);</span><br><span class="line">        mBuf.<span class="built_in">remove</span>(<span class="number">0</span>, endIndex + CmdEnd.<span class="built_in">length</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取指令</span></span><br><span class="line">        <span class="type">int</span> firstSplit = line.<span class="built_in">indexOf</span>(CmdSplit);</span><br><span class="line">        QString cmd = line.<span class="built_in">left</span>(firstSplit);</span><br><span class="line">        line.<span class="built_in">remove</span>(<span class="number">0</span>, firstSplit + CmdSplit.<span class="built_in">length</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理指令</span></span><br><span class="line">        <span class="built_in">processCmd</span>(cmd, line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ZeroClient::doGetTime</span><span class="params">(std::map&lt;QString, QString&gt; args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 从 QByteArray 中恢复 TimeData 结构体</span></span><br><span class="line"></span><br><span class="line">    QString data = args[<span class="string">&quot;TIME&quot;</span>];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function">emit <span class="title">timeDataReceived</span><span class="params">(data)</span></span>;  <span class="comment">// 发送信号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ZeroClient::processCmd</span><span class="params">(<span class="type">const</span> QString&amp; cmd, QString&amp; data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::map&lt;QString, QString&gt; args = <span class="built_in">parseArgs</span>(data);</span><br><span class="line">    std::cout &lt;&lt; cmd.<span class="built_in">toStdString</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; data.<span class="built_in">toStdString</span>() &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cmd == CmdGetTime)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">doGetTime</span>(args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//// 消息框命令</span></span><br><span class="line">    <span class="comment">//if (cmd == CmdSendMessage) &#123;</span></span><br><span class="line">    <span class="comment">//    doSendMessage(args);</span></span><br><span class="line">    <span class="comment">//    return;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//// 重新开机命令</span></span><br><span class="line">    <span class="comment">//if (cmd == CmdReboot) &#123;</span></span><br><span class="line">    <span class="comment">//    doReboot(args);</span></span><br><span class="line">    <span class="comment">//    return;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//// 退出本程序命令</span></span><br><span class="line">    <span class="comment">//if (cmd == CmdQuit) &#123;</span></span><br><span class="line">    <span class="comment">//    doQuit(args);</span></span><br><span class="line">    <span class="comment">//    return;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//// 屏幕监控命令</span></span><br><span class="line">    <span class="comment">//if (cmd == CmdScreenSpy) &#123;</span></span><br><span class="line">    <span class="comment">//    doScreenSpy(args);</span></span><br><span class="line">    <span class="comment">//    return;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//// 键盘监控命令</span></span><br><span class="line">    <span class="comment">//if (cmd == CmdKeyboardSpy) &#123;</span></span><br><span class="line">    <span class="comment">//    doKeyboardSpy(args);</span></span><br><span class="line">    <span class="comment">//    return;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//// 文件监控命令</span></span><br><span class="line">    <span class="comment">//if (cmd == CmdFileSpy) &#123;</span></span><br><span class="line">    <span class="comment">//    doFileSpy(args);</span></span><br><span class="line">    <span class="comment">//    return;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//// 命令行控制</span></span><br><span class="line">    <span class="comment">//if (cmd == CmdCmdSpy) &#123;</span></span><br><span class="line">    <span class="comment">//    doCmdSpy(args);</span></span><br><span class="line">    <span class="comment">//    return;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::map&lt;QString, QString&gt; <span class="title">ZeroClient::parseArgs</span><span class="params">(QString&amp; data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用QStringList进行字符串分割</span></span><br><span class="line">    QStringList parts = data.<span class="built_in">split</span>(CmdSplit);</span><br><span class="line">    std::map&lt;QString, QString&gt; args;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析参数，假设每两个元素为一个键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; parts.<span class="built_in">size</span>() - <span class="number">1</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">        args[parts.<span class="built_in">at</span>(i)] = parts.<span class="built_in">at</span>(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//void ZeroClient::doScreenSpy(std::map&lt;std::string, std::string&gt;&amp;)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//void ZeroClient::doKeyboardSpy(std::map&lt;std::string, std::string&gt;&amp;)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//void ZeroClient::doFileSpy(std::map&lt;std::string, std::string&gt;&amp;)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//void ZeroClient::doCmdSpy(std::map&lt;std::string, std::string&gt;&amp; args)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//void ZeroClient::doSendMessage(std::map&lt;std::string, std::string&gt;&amp; args)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    // 弹出窗口信息</span></span><br><span class="line"><span class="comment">//    MessageBoxA(NULL, args[&quot;TEXT&quot;].data(), &quot;Message&quot;, MB_OK);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//void ZeroClient::doReboot(std::map&lt;std::string, std::string&gt;&amp;)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    // 重启电脑</span></span><br><span class="line"><span class="comment">//    system(&quot;shutdown -r -t 1&quot;);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//void ZeroClient::doQuit(std::map&lt;std::string, std::string&gt;&amp;)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    // 退出本程序</span></span><br><span class="line"><span class="comment">//    ExitProcess(NULL);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Ccai</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">http://example.com/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Cc12138's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a></div><div class="post_share"><div class="social-share" data-image="/img/WangFei2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024%E9%99%A2%E8%B5%9Bpwn%E9%A2%98%E9%A2%98%E8%A7%A3/" title="院赛PWN方向WP"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">院赛PWN方向WP</div></div></a></div><div class="next-post pull-right"><a href="/Ark%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91/" title="ARK工具开发(持续更新)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">ARK工具开发(持续更新)</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/WangFei2.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Ccai</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">73</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">30</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/0xcc12138" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">ROIS Team Member</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">网络编程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Visual-Studio%E8%B7%A8%E5%B9%B3%E5%8F%B0"><span class="toc-number">2.</span> <span class="toc-text">Visual Studio跨平台</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-number">3.</span> <span class="toc-text">Linux前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E4%B8%8B%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5"><span class="toc-number">3.1.</span> <span class="toc-text">Linux下的编译和链接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E4%B8%8B%E7%9A%84%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">3.1.1.</span> <span class="toc-text">Linux下的动态链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GCC%E7%9A%84%E7%BC%96%E8%AF%91%E5%B8%B8%E8%A7%81%E9%80%89%E9%A1%B9"><span class="toc-number">3.1.2.</span> <span class="toc-text">GCC的编译常见选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#makefile"><span class="toc-number">3.1.3.</span> <span class="toc-text">makefile</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%92%8CWindows%E7%9A%84%E4%B8%80%E4%BA%9B%E7%B1%BB%E6%AF%94"><span class="toc-number">3.2.</span> <span class="toc-text">和Windows的一些类比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E7%9A%84%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%9A"><span class="toc-number">3.2.1.</span> <span class="toc-text">Linux的文件描述符：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.2.</span> <span class="toc-text">一些函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux-%E4%BF%A1%E5%8F%B7%EF%BC%88Signal%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">Linux 信号（Signal）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E4%B8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">3.4.</span> <span class="toc-text">Linux下的同步机制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%EF%BC%9A"><span class="toc-number">4.</span> <span class="toc-text">网络前置知识：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.0.1.</span> <span class="toc-text">网络模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ipv4%E5%92%8CMac%E5%9C%B0%E5%9D%80%EF%BC%9A"><span class="toc-number">4.0.2.</span> <span class="toc-text">Ipv4和Mac地址：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E7%BD%91%EF%BC%9A"><span class="toc-number">4.0.3.</span> <span class="toc-text">以太网：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ARP%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.0.4.</span> <span class="toc-text">ARP地址解析协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%BD%91%EF%BC%8C%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%EF%BC%8C%E7%BD%91%E5%85%B3"><span class="toc-number">4.0.5.</span> <span class="toc-text">子网，子网掩码，网关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VMWare%E7%9A%84%E6%A1%A5%E6%8E%A5%E5%92%8CNAT%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.0.6.</span> <span class="toc-text">VMWare的桥接和NAT的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.0.7.</span> <span class="toc-text">TCP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">4.0.7.1.</span> <span class="toc-text">特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">4.0.7.2.</span> <span class="toc-text">四次握手-&gt;三次握手</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96%EF%BC%9A"><span class="toc-number">4.0.7.2.1.</span> <span class="toc-text">三次握手的状态变化：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.0.7.2.2.</span> <span class="toc-text">可靠性的实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">4.0.7.3.</span> <span class="toc-text">四次挥手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8BTCP%E8%BF%9E%E6%8E%A5"><span class="toc-number">4.0.7.4.</span> <span class="toc-text">查看TCP连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E5%8D%8F%E8%AE%AE%E9%87%8D%E8%A6%81%E5%AD%97%E6%AE%B5%EF%BC%9A"><span class="toc-number">4.0.7.5.</span> <span class="toc-text">TCP协议重要字段：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.0.8.</span> <span class="toc-text">UDP协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E6%9C%BA%E5%9C%B0%E5%9D%80%E5%92%8C%E6%9C%AC%E5%9C%B0%E7%8E%AF%E5%9B%9E%E5%9C%B0%E5%9D%80"><span class="toc-number">4.0.9.</span> <span class="toc-text">本机地址和本地环回地址</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E4%B8%8B%E7%9A%84%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">Linux下的网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ip%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84%E5%92%8C%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="toc-number">5.1.</span> <span class="toc-text">ip地址结构和字节序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E7%BC%96%E7%A8%8B%E8%BF%87%E7%A8%8B"><span class="toc-number">5.2.</span> <span class="toc-text">TCP编程过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E5%87%BD%E6%95%B0"><span class="toc-number">5.3.</span> <span class="toc-text">重要函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%AD%E7%BA%BF%E9%87%8D%E8%BF%9E"><span class="toc-number">5.4.</span> <span class="toc-text">断线重连</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Windows%E4%B8%8B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">6.</span> <span class="toc-text">Windows下网络编程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">7.</span> <span class="toc-text">跨平台网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9C%E6%8E%A7%E9%A1%B9%E7%9B%AE"><span class="toc-number">7.1.</span> <span class="toc-text">远控项目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number">7.1.1.</span> <span class="toc-text">服务端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%9A"><span class="toc-number">7.1.2.</span> <span class="toc-text">客户端：</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Etw-ti%E7%9A%84%E5%BA%94%E7%94%A8/" title="ETW-Ti的应用记录">ETW-Ti的应用记录</a><time datetime="2025-02-06T11:18:00.000Z" title="发表于 2025-02-06 19:18:00">2025-02-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/%E6%8F%90%E5%8D%87%E8%BF%9B%E7%A8%8B%E8%87%B3PPL%E6%9D%83%E9%99%90/" title="将进程提升至PPL权限">将进程提升至PPL权限</a><time datetime="2025-02-05T07:44:00.000Z" title="发表于 2025-02-05 15:44:00">2025-02-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/WDF%E5%AD%A6%E4%B9%A0/" title="WDF框架学习">WDF框架学习</a><time datetime="2025-01-12T15:00:00.000Z" title="发表于 2025-01-12 23:00:00">2025-01-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/NDIS,WFP%E7%BD%91%E7%BB%9C%E8%BF%87%E6%BB%A4/" title="NDIS/WFP网络过滤">NDIS/WFP网络过滤</a><time datetime="2025-01-12T02:32:00.000Z" title="发表于 2025-01-12 10:32:00">2025-01-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/" title="病毒分析">病毒分析</a><time datetime="2025-01-06T14:11:00.000Z" title="发表于 2025-01-06 22:11:00">2025-01-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Ccai</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>